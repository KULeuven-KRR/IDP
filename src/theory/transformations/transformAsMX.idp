#include <mx>

vocabulary V{
	type op
	not:op
	type symbol
	type node contains op, symbol
	type time isa int
	type formula
	hasnode(formula, node, time)
	ischildof(formula, formula, time)
	//isreqchildof(formula, formula, time)
	type action
	push:action
	do(action, formula, time)
	affected(formula, time)
}
theory T : V{
	{
		affected(fp, t) <- do(action, fp, t).
		affected(fc, t) <- do(action, fp, t) & ischildof(fc, fp, t).
		//isreqchildof(f, fp, t) <- ischildof(f, fp, t).
		//isreqchildof(f, fa, t) <- isreqchildof(fp, fa, t) & ischildof(f, fp, t).
	}
	{
		hasnode(f, n, t+1) <- hasnode(f, n, t) & ~affected(f, t). // TODO BUG IN TYPE DERIVATION!
		ischildof(f, fp, t+1) <- ischildof(f, fp, t) & ~affected(f, t).
		
		hasnode(f, node, t+1) <- do(push, f, t) & hasnode(f, node, t) & node=not & ischildof(fc, f, t) & hasnode(fc, node, t).
		hasnode(f, node, t+1) <- do(push, f, t) & hasnode(f, node, t) & node~=not.
		ischildof(fc, f, t+1) <- do(push, f, t)  & ~hasnode(f, not, t) & ischildof(fc, f, t).
		ischildof(fcc, f, t+1) <- do(push, f, t) & hasnode(f, not, t) & ischildof(fc, f, t) & ischildof(fcc, fc, t).
	}
	!fp t: hasnode(fp, not, t) & ischildof(fc, fp, t) => ~hasnode(fc, not, t).
	
	!f t: hasnode(f, not, t) => #{fc: ischildof(fc, f, t)}=1.
}
structure S:V {
	formula = {1..10}
	op = {AND; OR; NOT}
	not = NOT
	symbol = {P}
	time = {1..10}
	action = {PUSH}
}