/*****************************************************************************
 * Copyright 2010-2012 Katholieke Universiteit Leuven
 *
 * Use of this software is governed by the GNU LGPLv3.0 license
 *
 * Written by Broes De Cat, Bart Bogaerts, Stef De Pooter, Johan Wittocx,
 * Jo Devriendt, Joachim Jansen and Pieter Van Hertum 
 * K.U.Leuven, Departement Computerwetenschappen,
 * Celestijnenlaan 200A, B-3001 Leuven, Belgium
 ****************************************************************************/

#include "IncludeComponents.hpp"
#include "errorhandling/error.hpp"
#include "structure/StructureComponents.hpp"
#include "utils/StringUtils.hpp"
#include "printers/print.hpp"

using namespace std;

/****
 * Interpretation generators
 */

/**
 * Class to overload predicates.
 */
class PredGenerator {
protected:
	std::string _name; //!< The name of the generated predicates
	unsigned int _arity; //!< The arity of the generated predicates
	bool _infix; //!< True iff the generated predicates are infix
public:
	virtual ~PredGenerator() {
	}

	PredGenerator(const std::string& name, unsigned int arity, bool infix);

	const std::string& name() const; //!< Returns the name of the generated predicates
	unsigned int arity() const; //!< Returns the arity of the generated predicates
	bool infix() const; //!< Returns true iff the generated predicates are infix

	virtual bool contains(const Predicate* predicate) const = 0;
	virtual Predicate* resolve(const std::vector<Sort*>&) = 0;
	virtual Predicate* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0) = 0;
	virtual std::set<Sort*> allsorts() const = 0;
	//!< Returns all sorts that occur in the predicates generated by the predicate generator
	virtual void addVocabulary(const Vocabulary*) = 0; //!< Add a vocabulary to all overloaded predicates
	virtual void removeVocabulary(const Vocabulary*) = 0; //!< Remove a vocabulary from all overloaded predicates

	virtual std::set<Predicate*> nonbuiltins() const = 0;
};

/**
 * PredGenerator containing a finite, enumerated number of predicates
 */
class EnumeratedPredGenerator: public PredGenerator {
private:
	std::set<Predicate*> _overpreds; //!< The overloaded predicates
public:
	~EnumeratedPredGenerator() {
	}

	EnumeratedPredGenerator(const std::set<Predicate*>&);

	bool contains(const Predicate* predicate) const;
	Predicate* resolve(const std::vector<Sort*>&);
	Predicate* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0);
	std::set<Sort*> allsorts() const;
	void addVocabulary(const Vocabulary*);
	void removeVocabulary(const Vocabulary*);

	std::set<Predicate*> nonbuiltins() const;
};

class PredInterGeneratorGenerator;

/**
 * Class to generate new predicates that are overloaded by </2, >/2, or =/2
 */
class ComparisonPredGenerator: public PredGenerator {
private:
	mutable std::map<Sort*, Predicate*> _overpreds;
	PredInterGeneratorGenerator* _interpretation;
public:
	ComparisonPredGenerator(const std::string& name, PredInterGeneratorGenerator* inter);
	~ComparisonPredGenerator();

	bool contains(const Predicate* predicate) const;

	Predicate* resolve(const std::vector<Sort*>&);
	Predicate* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0);
	std::set<Sort*> allsorts() const;
	void addVocabulary(const Vocabulary*);
	void removeVocabulary(const Vocabulary*);

	std::set<Predicate*> nonbuiltins() const;
};

/**
 * Class to generate new function.
 * Used to represent the infinite number of function that are overloaded by some built-in functions (e.g. SUCC/1)
 */
class FuncGenerator {
protected:
	std::string _name; //!< The name of the generated functions
	unsigned int _arity; //!< The arity of the generated functions
	unsigned int _binding; //!< The binding strength of the generated functions

public:
	virtual ~FuncGenerator() {
	}

	FuncGenerator(const std::string& name, unsigned int arity, unsigned int binding)
			: 	_name(name),
				_arity(arity),
				_binding(binding) {
	}

	const std::string& name() const; //!< Returns the name of the generated functions
	unsigned int arity() const; //!< Returns the arity of the generated functions
	unsigned int binding() const; //!< Returns the binding strength of the generated functions

	virtual bool contains(const Function* function) const = 0;
	virtual Function* resolve(const std::vector<Sort*>&) = 0;
	virtual Function* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0) = 0;
	virtual std::set<Sort*> allsorts() const = 0;
	virtual void addVocabulary(const Vocabulary*) = 0;
	virtual void removeVocabulary(const Vocabulary*) = 0;

	virtual std::set<Function*> nonbuiltins() const = 0;
};

/**
 * FuncGenerator containing a finite, enumerated number of functions
 */
class EnumeratedFuncGenerator: public FuncGenerator {
private:
	std::set<Function*> _overfuncs; //!< The overloaded predicates
public:
	~EnumeratedFuncGenerator() {
	}

	EnumeratedFuncGenerator(const std::set<Function*>&);

	bool contains(const Function* function) const;
	Function* resolve(const std::vector<Sort*>&);
	Function* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0);
	std::set<Sort*> allsorts() const;
	void addVocabulary(const Vocabulary*);
	void removeVocabulary(const Vocabulary*);

	std::set<Function*> nonbuiltins() const;
};

/**
 * FuncGenerator containing two functions: one with sorts [int,int:int], one with sorts [float,float:float].
 * Used for many standard arithmetic functions.
 */
class IntFloatFuncGenerator: public FuncGenerator {
private:
	Function* _intfunction;
	Function* _floatfunction;
public:

	IntFloatFuncGenerator(Function* intfunc, Function* floatfunc);
	~IntFloatFuncGenerator() {
	}

	bool contains(const Function* function) const;
	Function* resolve(const std::vector<Sort*>&);
	Function* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0);
	std::set<Sort*> allsorts() const;
	void addVocabulary(const Vocabulary*);
	void removeVocabulary(const Vocabulary*);

	std::set<Function*> nonbuiltins() const;
};

class FuncInterGeneratorGenerator;

/**
 * Class to overload the functions MIN/0, MAX/0, SUCC/1, and PRED/1
 */
class OrderFuncGenerator: public FuncGenerator {
private:
	FuncInterGeneratorGenerator* _interpretation;
public:
	OrderFuncGenerator(const std::string& name, unsigned int arity, FuncInterGeneratorGenerator* inter);
	~OrderFuncGenerator();

	bool contains(const Function* function) const;
	Function* resolve(const std::vector<Sort*>&);
	Function* disambiguate(const std::vector<Sort*>&, const Vocabulary* v = 0);
	std::set<Sort*> allsorts() const;
	void addVocabulary(const Vocabulary*);
	void removeVocabulary(const Vocabulary*);

	std::set<Function*> nonbuiltins() const;
};

/***********
 *	Sorts
 **********/

/**
 * Destructor for sorts. 
 * Deletes the built-in interpretation and removes the sort from the sort hierarchy.
 */
Sort::~Sort() {
	for (auto it = _parents.cbegin(); it != _parents.cend(); ++it) {
		(*it)->removeChild(this);
	}
	for (auto it = _children.cbegin(); it != _children.cend(); ++it) {
		(*it)->removeParent(this);
	}
	if (_interpretation) {
		delete (_interpretation);
	}
}

void Sort::removeVocabulary(const Vocabulary* vocabulary) {
	_vocabularies.erase(vocabulary);
	if (_vocabularies.empty()) {
		delete (this);
	}
}

void Sort::addVocabulary(const Vocabulary* vocabulary) {
	_vocabularies.insert(vocabulary);
}

/**
 * Removes a sort from the set of parents
 *
 * PARAMETERS
 *		- parent: the parent that is removed
 */
void Sort::removeParent(Sort* parent) {
	_parents.erase(parent);
}

/**
 * Removes a sort from the set of children
 *
 * PARAMETERS
 *		- child: the child that is removed
 */
void Sort::removeChild(Sort* child) {
	_children.erase(child);
}

void Sort::generatePred() {
	// Generate the corresponding predicate
	string predname(_name + "/1");
	if (builtin()) {
		auto pt = new PredTable(new FullInternalPredTable(), Universe( { interpretation() }));
		auto pinter = new PredInter(pt, true);
		auto pig = new SinglePredInterGenerator(pinter);
		_pred = new Predicate(predname, { this }, pig, false);
	} else {
		_pred = new Predicate(predname, { this }, _pi);
	}
}

Sort::Sort(SortTable* inter)
		: 	_pi(),
			_interpretation(inter),
			sortConstructed(false){
	_name = "sort" + convertToString(getGlobal()->getNewID());
	generatePred();
}
Sort::Sort(const string& name, SortTable* inter)
		: 	_name(name),
			_pi(),
			_interpretation(inter),
			sortConstructed(false){
	generatePred();
}

Sort::Sort(const string& name, const ParseInfo& pi, SortTable* inter)
		: 	_name(name),
			_pi(pi),
			_interpretation(inter),
			sortConstructed(false){
	generatePred();
}

void Sort::addParent(Sort* p) {
	pair<set<Sort*>::iterator, bool> changed = _parents.insert(p);
	if (changed.second) {
		p->addChild(this);
	}
}

void Sort::addChild(Sort* c) {
	pair<set<Sort*>::iterator, bool> changed = _children.insert(c);
	if (changed.second) {
		c->addParent(this);
	}
}

/**
 * Compute all ancestors of the sort in the sort hierarchy
 *
 * PARAMETERS
 *		- vocabulary:	if this is not a null-pointer, the set of ancestors is restricted to the ancestors in vocabulary
 */
set<Sort*> Sort::ancestors(const Vocabulary* vocabulary) const {
	set<Sort*> ancest;
	for (auto it = _parents.cbegin(); it != _parents.cend(); ++it) {
		if ((not vocabulary) || vocabulary->contains(*it)) {
			ancest.insert(*it);
		}
		set<Sort*> temp = (*it)->ancestors(vocabulary);
		ancest.insert(temp.cbegin(), temp.cend());
	}
	return ancest;
}

/**
 * Compute all descendents of the sort in the sort hierarchy
 *
 * PARAMETERS
 *		- vocabulary:	if this is not a null-pointer, the set of descendents is restricted to the descendents in vocabulary
 */
set<Sort*> Sort::descendents(const Vocabulary* vocabulary) const {
	set<Sort*> descend;
	for (auto it = _children.cbegin(); it != _children.cend(); ++it) {
		if ((not vocabulary) || vocabulary->contains(*it)) {
			descend.insert(*it);
		}
		set<Sort*> temp = (*it)->descendents(vocabulary);
		descend.insert(temp.cbegin(), temp.cend());
	}
	return descend;
}

bool Sort::isConstructed() const {
	return sortConstructed;
}

bool Sort::hasFixedInterpretation() const {
	return _interpretation != NULL || isConstructed();
}

bool Sort::builtin() const {
	return _interpretation != NULL;
}

void Sort::setConstructed(bool constructed) {
	Assert(_interpretation == NULL);
	sortConstructed = constructed;
}

void Sort::addConstructor(Function* func) {
	Assert(sortConstructed);
	_constructors.push_back(func);
}

SortTable* Sort::interpretation() const {
	Assert(builtin());
	return _interpretation;
}
const std::set<const Vocabulary*>& Sort::getVocabularies() const {
        return _vocabularies;
}

SortTable* getConstructedInterpretation(Sort* s, const Structure* struc) {
	Assert(s->isConstructed());
	return new SortTable(new ConstructedInternalSortTable(struc, s->getConstructors()));
}
ostream& Sort::put(ostream& output) const {
	if (getOption(BoolType::LONGNAMES)) {
		for (auto it = _vocabularies.cbegin(); it != _vocabularies.cend(); ++it) {
			if ((*it)->sort(_name) != NULL) {
				(*it)->putName(output);
				output << "::";
				break;
			}
		}
	}
	output << _name;
	return output;
}

bool operator<(const Sort& s1, const Sort& s2) {
    return s1.name() < s2.name();
}


UnionSort::UnionSort(const std::vector<Sort*>& sorts)
		: 	Sort("union"),
			sorts(sorts) {
	stringstream ss;
	for (auto i = sorts.cbegin(); i < sorts.cend(); ++i) {
		ss << (*i)->name() << "-";
	}
	setPred(new Predicate(ss.str() + "/1", { this }, pi()));
}

namespace SortUtils {
/**
 *	\brief	Return the unique nearest common ancestor of two sorts.
 *
 *	\param s1			the first sort
 *	\param s2			the second sort
 *	\param vocabulary	if not NULL, search for the nearest common ancestor in the projection 
 *						of the sort hiearchy on this vocabulary
 *
 *	\return	The unique nearest common ancestor if it exists, a null-pointer otherwise.
 *	Returns NULL if any of the given sorts is NULL.
 */
Sort* resolve(Sort* s1, Sort* s2, const Vocabulary* voc) {
	if (s1 == NULL or s2 == NULL) {
		return NULL;
	}
	auto ss1 = s1->ancestors(voc);
	ss1.insert(s1);
	auto ss2 = s2->ancestors(voc);
	ss2.insert(s2);
	set<Sort*> ss;
	for (auto it = ss1.cbegin(); it != ss1.cend(); ++it) {
		if (ss2.find(*it) != ss2.cend()) {
			ss.insert(*it);
		}
	}
	auto vs = vector<Sort*>(ss.cbegin(), ss.cend());
	if (vs.empty()) {
		return NULL;
	} else if (vs.size() == 1) {
		return vs[0];
	} else {
		for (size_t n = 0; n < vs.size(); ++n) {
			auto ds = vs[n]->ancestors(voc);
			for (auto it = ds.cbegin(); it != ds.cend(); ++it) {
				ss.erase(*it);
			}
		}
		vs = vector<Sort*>(ss.cbegin(), ss.cend());
		if (vs.size() == 1) {
			return vs[0];
		} else {
			return NULL;
		}
	}
}

bool isSubsort(Sort* a, Sort* b, const Vocabulary* voc) {
	if (a == NULL or b == NULL or (voc != NULL and (not voc->contains(a) or not voc->contains(b)))) {
		return false;
	}
	if (a == b) {
		return true;
	}
	for (auto parent : a->parents()) {
		if (isSubsort(parent, b, NULL)) {
			return true;
		}
	}
	return false;
}

}

/***************
 *	Variables
 **************/

Variable::~Variable() {
}

Variable::Variable(const std::string& name, Sort* sort, const ParseInfo& pi)
		: 	_name(name),
			_sort(sort),
			_pi(pi) {
}

Variable::Variable(Sort* s)
		: _sort(s) {
	stringstream ss;
	ss <<"var" << convertToString(getGlobal()->getNewID());
	_name = ss.str();
}

void Variable::sort(Sort* s) {
	_sort = s;
}

const string& Variable::name() const {
	return _name;
}

Sort* Variable::sort() const {
	return _sort;
}

const ParseInfo& Variable::pi() const {
	return _pi;
}

ostream& Variable::put(ostream& output) const {
	output << _name;
	if (_sort) {
		output << '[';
		_sort->put(output);
		output << ']';
	}
	return output;
}

ostream& operator<<(ostream& output, const Variable& var) {
	return var.put(output);
}

vector<Variable*> VarUtils::makeNewVariables(const vector<Sort*>& sorts) {
	vector<Variable*> vars;
	for (auto it = sorts.cbegin(); it != sorts.cend(); ++it) {
		vars.push_back(new Variable(*it));
	}
	return vars;
}

/******************************
 *	Predicates and functions
 *****************************/

PFSymbol::~PFSymbol() {
	for (auto it = _derivedsymbols.cbegin(); it != _derivedsymbols.cend(); ++it) {
		delete (it->second);
	}
}

PFSymbol::PFSymbol(const string& name, size_t nrsorts, bool infix)
		: 	_name(name),
			_sorts(nrsorts, 0),
			_infix(infix) {
}

PFSymbol::PFSymbol(const string& name, const vector<Sort*>& sorts, bool infix)
		: 	_name(name),
			_sorts(sorts),
			_infix(infix) {
}

PFSymbol::PFSymbol(const string& name, const vector<Sort*>& sorts, const ParseInfo& pi, bool infix)
		: 	_name(name),
			_pi(pi),
			_sorts(sorts),
			_infix(infix) {
}

bool PFSymbol::removeVocabulary(const Vocabulary* voc) {
	auto nb = _vocabularies.erase(voc);
	return nb != 0;
}
void PFSymbol::addVocabulary(const Vocabulary* voc) {
	_vocabularies.insert(voc);
}

const string& PFSymbol::name() const {
	return _name;
}
string PFSymbol::nameNoArity() const {
	unsigned found = name().find_last_of("/");
	return name().substr(0, found);
}
std::string PFSymbol::fqn_name() const {
	return toString(this);
}
const ParseInfo& PFSymbol::pi() const {
	return _pi;
}

size_t PFSymbol::nrSorts() const {
	return sorts().size();
}

Sort* PFSymbol::sort(size_t n) const {
	return sorts()[n];
}

bool PFSymbol::infix() const {
	return _infix;
}

bool PFSymbol::hasVocabularies() const {
	return not _vocabularies.empty();
}

Predicate* PFSymbol::derivedSymbol(SymbolType type) {
	Assert(type != ST_NONE);
	auto it = _derivedsymbols.find(type);
	if (it == _derivedsymbols.cend()) {
		auto derp = new Predicate(_name, sorts(), _pi, _infix);
		derp->type(type, this);
		_derivedsymbols[type] = derp;
		return derp;
	} else {
		return it->second;
	}
}

vector<unsigned int> PFSymbol::argumentNrs(const Sort* soort) const {
	vector<unsigned int> result;
	for (unsigned int i = 0; i < nrSorts(); ++i) {
		if (sort(i) == soort) {
			result.push_back(i);
		}
	}
	return result;
}

ostream& operator<<(ostream& output, const PFSymbol& s) {
	return s.put(output);
}

set<Sort*> Predicate::allsorts() const {
	set<Sort*> ss;
	ss.insert(sorts().cbegin(), sorts().cend());
	if (_overpredgenerator) {
		set<Sort*> os = _overpredgenerator->allsorts();
		ss.insert(os.cbegin(), os.cend());
	}
	ss.erase(0);
	return ss;
}

Predicate::~Predicate() {
	if (_interpretation) {
		delete (_interpretation);
	}
	if (_overpredgenerator) {
		delete (_overpredgenerator);
	}
}

bool Predicate::removeVocabulary(const Vocabulary* vocabulary) {
	PFSymbol::removeVocabulary(vocabulary);
	if (overloaded()) {
		_overpredgenerator->removeVocabulary(vocabulary);
	}
	if (not hasVocabularies()) {
		delete (this);
		return true;
	}
	return false;
}

void Predicate::addVocabulary(const Vocabulary* vocabulary) {
	PFSymbol::addVocabulary(vocabulary);
	if (overloaded()) {
		_overpredgenerator->addVocabulary(vocabulary);
	}
}

Predicate::Predicate(const std::string& name, const std::vector<Sort*>& sorts, const ParseInfo& pi, bool infix)
		: 	PFSymbol(name, sorts, pi, infix),
			_type(ST_NONE),
			_parent(0),
			_interpretation(0),
			_overpredgenerator(0) {
}

Predicate::Predicate(const vector<Sort*>& sorts)
		: 	PFSymbol("", sorts, ParseInfo()),
			_type(ST_NONE),
			_parent(0),
			_interpretation(0),
			_overpredgenerator(0) {
	setName("idp_" + convertToString(getGlobal()->getNewID()) + "/" + convertToString(sorts.size()));
}

Predicate::Predicate(const std::string& name, const std::vector<Sort*>& sorts, PredInterGenerator* inter, bool infix)
		: 	PFSymbol(name, sorts, infix),
			_type(ST_NONE),
			_parent(0),
			_interpretation(inter),
			_overpredgenerator(0) {
}

Predicate::Predicate(PredGenerator* generator)
		: 	PFSymbol(generator->name(), generator->arity(), generator->infix()),
			_type(ST_NONE),
			_parent(0),
			_interpretation(0),
			_overpredgenerator(generator) {
}

bool Predicate::builtin() const {
	return _interpretation != 0;
}

bool Predicate::isNonConstructorBuiltin() const {
	return builtin(); // predicates cannot be constructors
}


bool Predicate::overloaded() const {
	return (_overpredgenerator != 0);
}

void Predicate::type(SymbolType type, PFSymbol* parent) {
	_type = type;
	_parent = parent;
}

/**
 * \brief Returns the interpretation of a built-in predicate
 *
 * PARAMETERS
 *		 - structure: for some predicates, e.g. =/2 over a type A, the interpretation of A is 
 *		 needed to generate the interpretation for =/2. The structure contains the interpretation of the 
 *		 relevant sorts.
 */
PredInter* Predicate::interpretation(const Structure* structure) const {
	if (_interpretation) {
		return _interpretation->get(structure);
	} else {
		return 0;
	}
}

/**
 * \brief Returns true iff the predicate is equal to, or overloads a given predicate
 *
 * PARAMETERS
 *		- predicate: the given predicate
 */
bool Predicate::contains(const Predicate* predicate) const {
	if (this == predicate) {
		return true;
	} else if (_overpredgenerator && _overpredgenerator->contains(predicate)) {
		return true;
	} else {
		return false;
	}
}

/**
 * \brief Return a unique predicate that is overloaded by the predicate and which has given sorts.
 *
 * PARAMETERS
 *		- sorts: the sorts the returned predicate should have.
 *
 * RETURNS
 *		- The predicate itself if it is not overloaded and matches the given sorts.
 *		- A null-pointer if there is more than one predicate that is overloaded by the predicate
 *		  and matches the given sorts.
 *		- Otherwise, the unique predicate that is overloaded by the predicate and matches the given sorts.
 */
Predicate* Predicate::resolve(const vector<Sort*>& ambigsorts) {
	if (overloaded()) {
		return _overpredgenerator->resolve(ambigsorts);
	} else if (sorts() == ambigsorts) {
		return this;
	} else {
		return NULL;
	}
}

/**
 * \brief Returns a predicate that is overloaded by the predicate and which has sorts that resolve with the given sorts.
 * Which predicate is returned may depend on the overpredgenerator. Returns a null-pointer if no
 * suitable predicate is found.
 *
 * PARAMETERS
 *		- sorts:		the given sorts
 *		- vocabulary:	the vocabulary used for resolving the sorts. Defaults to 0.
 */
Predicate* Predicate::disambiguate(const vector<Sort*>& ambigsorts, const Vocabulary* vocabulary) {
	if (overloaded()) {
		return _overpredgenerator->disambiguate(ambigsorts, vocabulary);
	} else {
		for (size_t n = 0; n < sorts().size(); ++n) {
			if (sorts()[n] && not SortUtils::resolve(ambigsorts[n], sorts()[n], vocabulary)) {
				return NULL;
			}
		}
		return this;
	}
}

/**
 *		\brief Returns a function that is overloaded by the function and which sorts resolve with the given sorts.
 *		Which function is returned may depend on the overfuncgenerator. Returns a null-pointer if no
 *		suitable function is found.
 *
 * PARAMETERS
 *		- sorts:		the given sorts (includes the output sort)
 *		- vocabulary:	the vocabulary used for resolving the sorts. Defaults to 0.
 */
Function* Function::disambiguate(const vector<Sort*>& ambigsorts, const Vocabulary* vocabulary) {
	Assert(ambigsorts.size() == sorts().size());
	if (overloaded()) {
		return _overfuncgenerator->disambiguate(ambigsorts, vocabulary);
	} else {
		for (size_t n = 0; n < sorts().size(); ++n) {
			if (sorts()[n] != NULL && not SortUtils::resolve(ambigsorts[n], sorts()[n], vocabulary) && ambigsorts[n] != NULL) {
				return NULL;
			}
		}
		return this;
	}
}

set<Predicate*> Predicate::nonbuiltins() {
	if (_overpredgenerator) {
		return _overpredgenerator->nonbuiltins();
	} else {
		set<Predicate*> sp;
		if (not _interpretation) {
			sp.insert(this);
		}
		return sp;
	}
}

ostream& Predicate::put(ostream& output) const {
	if (getOption(BoolType::LONGNAMES)) {
		for (auto voc : getVocabularies()) {
			if (not voc->pred(name())->overloaded()) {
				voc->putName(output);
				output << "::";
				break;
			}
		}
	}
	output << name().substr(0, name().rfind('/'));
	if (not overloaded()) { // It is a disambiguated symbol
		auto confusionpossible = false;
		for (auto voc : getVocabularies()) {
			if (voc->pred(name())->overloaded()) {
				confusionpossible = true;
				break;
			}

			//Check if there is a function with the same name
			if (VocabularyUtils::containsSymbol(name(), (arity() - 1), Vocabulary::Symbol::FUNCTION, voc)) {
				confusionpossible = true;
				break;
			}
		}
		if (nrSorts() > 0 && (confusionpossible || getOption(BoolType::LONGNAMES))) {
			output << '[';
			sort(0)->put(output);
			for (size_t n = 1; n < nrSorts(); ++n) {
				output << ',';
				sort(n)->put(output);
			}
			output << ']';
		}
	}
	switch (_type) {
	case ST_NONE:
		break;
	case ST_CT:
		output << "<ct>";
		break;
	case ST_CF:
		output << "<cf>";
		break;
	case ST_PT:
		output << "<pt>";
		break;
	case ST_PF:
		output << "<pf>";
		break;
	}
	return output;
}

ostream& operator<<(ostream& output, const Predicate& p) {
	return p.put(output);
}

PredGenerator::PredGenerator(const string& name, unsigned int arity, bool infix)
		: 	_name(name),
			_arity(arity),
			_infix(infix) {
}

const string& PredGenerator::name() const {
	return _name;
}

unsigned int PredGenerator::arity() const {
	return _arity;
}

bool PredGenerator::infix() const {
	return _infix;
}

EnumeratedPredGenerator::EnumeratedPredGenerator(const set<Predicate*>& overpreds)
		: 	PredGenerator((*(overpreds.cbegin()))->name(), (*(overpreds.cbegin()))->arity(), (*(overpreds.cbegin()))->infix()),
			_overpreds(overpreds) {
}

bool EnumeratedPredGenerator::contains(const Predicate* predicate) const {
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		if ((*it)->contains(predicate)) {
			return true;
		}
	}
	return false;
}

/**
 * \brief Returns the unique predicate that is contained in the generator and that has the given sorts.
 * \brief Returns a null-pointer if such a predicate does not exist or is not unique
 */
Predicate* EnumeratedPredGenerator::resolve(const vector<Sort*>& sorts) {
	Predicate* candidate = NULL;
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		Predicate* newcandidate = (*it)->resolve(sorts);
		if (newcandidate) {
			if (candidate and candidate != newcandidate) {
				return NULL;
			} else {
				candidate = newcandidate;
			}
		}
	}
	return candidate;
}

/**
 * \brief Returns the unique predicate that is contained in the generator and which sorts resolve with the given sorts.
 * \brief Returns a null-pointer if such a predicate does not exist or is not unique
 */
Predicate* EnumeratedPredGenerator::disambiguate(const vector<Sort*>& sorts, const Vocabulary* vocabulary) {
	Predicate* candidate = NULL;
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		Predicate* newcandidate = (*it)->disambiguate(sorts, vocabulary);
		if (newcandidate) {
			if (candidate and candidate != newcandidate) {
				return NULL;
			} else {
				candidate = newcandidate;
			}
		}
	}
	return candidate;
}

set<Sort*> EnumeratedPredGenerator::allsorts() const {
	set<Sort*> ss;
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		set<Sort*> os = (*it)->allsorts();
		ss.insert(os.cbegin(), os.cend());
	}
	ss.erase(0);
	return ss;
}

void EnumeratedPredGenerator::addVocabulary(const Vocabulary* vocabulary) {
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		(*it)->addVocabulary(vocabulary);
	}
}

void EnumeratedPredGenerator::removeVocabulary(const Vocabulary* vocabulary) {
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend();) {
		auto removed = (*it)->removeVocabulary(vocabulary);
		if (removed) {
			it = _overpreds.erase(it);
		} else {
			++it;
		}
	}
}

set<Predicate*> EnumeratedPredGenerator::nonbuiltins() const {
	set<Predicate*> sp;
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		set<Predicate*> temp = (*it)->nonbuiltins();
		sp.insert(temp.cbegin(), temp.cend());
	}
	return sp;
}

ComparisonPredGenerator::ComparisonPredGenerator(const string& name, PredInterGeneratorGenerator* inter)
		: 	PredGenerator(name, 2, true),
			_interpretation(inter) {
}

ComparisonPredGenerator::~ComparisonPredGenerator() {
	delete (_interpretation);
	for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		if (not it->second->hasVocabularies()) {
			//delete (it->second);
		}
	}
}

/**
 * \brief Returns true iff predicate has the same name as the generator, and both sorts of the predicate are equal
 */
bool ComparisonPredGenerator::contains(const Predicate* predicate) const {
	if (predicate->name() == _name) {
		Assert(predicate->arity() == 2);
		return predicate->sort(0) == predicate->sort(1);
	} else {
		return false;
	}
}

/**
 * \brief Returns the unique predicate that has the name of the generator and the given sorts
 */
Predicate* ComparisonPredGenerator::resolve(const vector<Sort*>& sorts) {
	if (sorts.size() == 2 && sorts[0] == sorts[1]) {
		auto it = _overpreds.find(sorts[0]);
		if (it == _overpreds.cend()) {
			return disambiguate(sorts);
		} else {
			return it->second;
		}
	}
	return 0;
}

/**
 * \brief Returns the predicate P[A,A], where P is the name of the generator and A is the unique least common
 * \brief ancestor of all the given sorts.
 *
 * Returns null-pointer if
 *	- there is no least common ancestor of the non-null pointers among the given sorts.
 *	- the vector of given sorts contains a null-pointer and the least common ancestor has an ancestor in the
 *	given vocabulary
 */
Predicate* ComparisonPredGenerator::disambiguate(const vector<Sort*>& sorts, const Vocabulary* vocabulary) {
	Sort* predSort = NULL;
	bool sortsContainsZero = false;
	for (auto it = sorts.cbegin(); it != sorts.cend(); ++it) {
		if ((*it) == NULL) {
			sortsContainsZero = true;
			continue;
		}
		if (predSort != NULL) {
			predSort = SortUtils::resolve(predSort, *it, vocabulary);
			if (predSort == NULL) {
				return NULL;
			}
		} else {
			predSort = *it;
		}
	}

	Predicate* pred = NULL;
	if (predSort && (not sortsContainsZero || not predSort->ancestors(vocabulary).empty())) {
		auto it = _overpreds.find(predSort);
		if (it != _overpreds.cend()) {
			pred = it->second;
		} else {
			vector<Sort*> predSorts(2, predSort);
			pred = new Predicate(_name, predSorts, _interpretation->get(predSorts), true);
			_overpreds[predSort] = pred;
		}
	}
	return pred;
}

set<Sort*> ComparisonPredGenerator::allsorts() const {
	set<Sort*> ss;
	return ss;
}

void ComparisonPredGenerator::addVocabulary(const Vocabulary*) {
	/*for (auto it = _overpreds.cbegin(); it != _overpreds.cend(); ++it) {
		it->second->addVocabulary(vocabulary);
	}*/
}

void ComparisonPredGenerator::removeVocabulary(const Vocabulary*) {
	/*for (auto it = _overpreds.begin(); it != _overpreds.end();) {
		map<Sort*, Predicate*>::iterator jt = it;
		++it;
		if (jt->second->removeVocabulary(vocabulary)) {
			_overpreds.erase(jt);
		}
		}*/
}

set<Predicate*> ComparisonPredGenerator::nonbuiltins() const {
	set<Predicate*> sp;
	return sp;
}

namespace PredUtils {

Predicate* overload(Predicate* p1, Predicate* p2) {
	Assert(p1->name() == p2->name());
	if (p1 == p2) {
		return p1;
	}
	set<Predicate*> sp;
	sp.insert(p1);
	sp.insert(p2);
	return overload(sp);
}

Predicate* overload(const set<Predicate*>& sp) {
	if (sp.empty()) {
		return NULL;
	} else if (sp.size() == 1) {
		return *(sp.cbegin());
	} else {
		auto epg = new EnumeratedPredGenerator(sp);
		return new Predicate(epg);
	}
}

bool isTypePredicate(const Predicate* p) {
	return p->nrSorts() == 1 and p == p->sort(0)->pred();
}

}

Function::Function(const std::string& name, const std::vector<Sort*>& is, Sort* os, const ParseInfo& pi, bool isConstructor)
		: 	PFSymbol(name, is, pi),
			_partial(false),
			_insorts(is),
			_outsort(os),
			_interpretation(NULL),
			_overfuncgenerator(NULL),
			_binding(0),
			_isConstructor(isConstructor) {
	addSort(os);
	if (isConstructor) {
		_interpretation = new ConstructorFuncInterGenerator(this);
	}
}

Function::Function(const std::vector<Sort*>& is, Sort* os, const ParseInfo& pi, unsigned int binding)
		: 	PFSymbol("", is, pi),
			_partial(false),
			_insorts(is),
			_outsort(os),
			_interpretation(NULL),
			_overfuncgenerator(NULL),
			_binding(binding),
			_isConstructor(false) {
	addSort(os);
	setName("_intern_func_" + convertToString(getGlobal()->getNewID()) + "/" + convertToString(is.size() + 1));
}

Function::Function(const std::string& name, const std::vector<Sort*>& sorts, FuncInterGenerator* inter, unsigned int binding)
		: 	PFSymbol(name, sorts, binding != 0),
			_partial(false),
			_insorts(sorts),
			_outsort(sorts.back()),
			_interpretation(inter),
			_overfuncgenerator(NULL),
			_binding(binding),
			_isConstructor(false) {
	_insorts.pop_back();
}

Function::Function(FuncGenerator* generator)
		: 	PFSymbol(generator->name(), generator->arity() + 1, generator->binding() != 0),
			_partial(true),
			_insorts(generator->arity(), NULL),
			_outsort(NULL),
			_interpretation(NULL),
			_overfuncgenerator(generator),
			_binding(generator->binding()),
			_isConstructor(false) /* currently no generators for constructor functions exist */{
}

Function::~Function() {
	if (_interpretation) {
		delete (_interpretation);
	}
	if (_overfuncgenerator) {
		delete (_overfuncgenerator);
	}
}

void Function::partial(bool b) {
	_partial = b;
}

bool Function::removeVocabulary(const Vocabulary* vocabulary) {
	PFSymbol::removeVocabulary(vocabulary);
	if (overloaded()) {
		_overfuncgenerator->removeVocabulary(vocabulary);
	}
	if (not hasVocabularies()) {
		delete (this);
		return true;
	}
	return false;
}

void Function::addVocabulary(const Vocabulary* vocabulary) {
	PFSymbol::addVocabulary(vocabulary);
	if (overloaded()) {
		_overfuncgenerator->addVocabulary(vocabulary);
	}
}

set<Sort*> Function::allsorts() const {
	set<Sort*> ss;
	ss.insert(sorts().cbegin(), sorts().cend());
	if (_overfuncgenerator != NULL) {
		set<Sort*> os = _overfuncgenerator->allsorts();
		ss.insert(os.cbegin(), os.cend());
	}
	ss.erase(NULL);
	return ss;
}

const vector<Sort*>& Function::insorts() const {
	return _insorts;
}

Sort* Function::insort(unsigned int n) const {
	return _insorts[n];
}

Sort* Function::outsort() const {
	return _outsort;
}

bool Function::partial() const {
	return _partial;
}

bool Function::builtin() const {
	return _interpretation != NULL || Vocabulary::std()->contains(this);
}

bool Function::isNonConstructorBuiltin() const {
	return (builtin() and not isConstructorFunction());
}

FuncGenerator* Function::overfuncgenerator() const {
	return _overfuncgenerator;
}

bool Function::overloaded() const {
	return (_overfuncgenerator != 0);
}

bool Function::hasDerivableSorts() const {
	return not builtin() || _isConstructor;
}

unsigned int Function::binding() const {
	return _binding;
}

/**
 * \brief Returns the interpretation of a function in the given structure (if any)
 */
FuncInter* Function::interpretation(const Structure* structure) const {
	if (_interpretation) {
		return _interpretation->get(structure);
	} else if (structure != NULL) {
		return structure->inter(this);
	} else {
		return NULL;
	}
}

/**
 * \brief Returns true iff the function is equal to, or overloads a given function
 *
 * PARAMETERS
 *		- function: the given function
 */
bool Function::contains(const Function* function) const {
	if (this == function) {
		return true;
	} else if (_overfuncgenerator && _overfuncgenerator->contains(function)) {
		return true;
	} else {
		return false;
	}
}

/**
 * \brief Return a unique function that is overloaded by the function and which has given sorts.
 *
 * PARAMETERS
 *		- sorts: the sorts the returned function should have. Includes the return sort
 *
 * RETURNS
 *		- The function itself if it is not overloaded and matches the given sorts.
 *		- A null-pointer if there is more than one function that is overloaded by the function
 *		  and matches the given sorts.
 *		- Otherwise, the unique function that is overloaded by the function and matches the 
 *		  given sorts.
 */
Function* Function::resolve(const vector<Sort*>& ambigsorts) {
	if (overloaded()) {
		return _overfuncgenerator->resolve(ambigsorts);
	} else if (sorts() == ambigsorts) {
		return this;
	} else {
		return NULL;
	}
}

/**
 * FIXME: preferably, this is a const method which return a set of const functions
 * BUT functions are often used non const as map keys. As it is impossible to find using const Functions without a const_cast,
 * we prefer having a bit of ugly code here and the const cast once in a while when the user possesses a const function himself.
 */
set<Function*> Function::nonbuiltins() {
	if (_overfuncgenerator) {
		return _overfuncgenerator->nonbuiltins();
	} else {
		set<Function*> sf;
		if (not _interpretation) {
			sf.insert(this);
		}
		return sf;
	}
}

ostream& Function::put(ostream& output) const {
	if (getOption(BoolType::LONGNAMES)) {
		for (auto voc : getVocabularies()) {
			if (not voc->func(name())->overloaded()) {
				voc->putName(output);
				output << "::";
				break;
			}
		}
	}
	output << name().substr(0, name().rfind('/'));
	// We don't want to print for every overloaded built in function (like +) all the sorts
	// However, we do need this for constants like MAX and MIN
	// TODO: Can be dangerous if the user overloads these built in functions
	if (not overloaded() && (not builtin() or arity() == 0)) { // It is a disambiguated symbol
		auto confusionpossible = false;
		for (auto voc : getVocabularies()) {
			if (voc->func(name())->overloaded()) {
				confusionpossible = true;
				break;
			}
			//Check if there is a predicate with the same name
			if (VocabularyUtils::containsSymbol(name(), (arity() + 1), Vocabulary::Symbol::PREDICATE, voc)) {
				confusionpossible = true;
				break;
			}
		}
		if (Vocabulary::std()->contains(this) && Vocabulary::std()->func(name())->overloaded()) {
			confusionpossible = true;
		}
		if (confusionpossible || getOption(BoolType::LONGNAMES)) {
			output << '[';
			if (not _insorts.empty()) {
				_insorts[0]->put(output);
				for (size_t n = 1; n < _insorts.size(); ++n) {
					output << ',';
					_insorts[n]->put(output);
				}
			}
			output << " : ";
			_outsort->put(output);
			output << ']';
		}
	}
	return output;
}

ostream& operator<<(ostream& output, const Function& f) {
	return f.put(output);
}

const string& FuncGenerator::name() const {
	return _name;
}

unsigned int FuncGenerator::arity() const {
	return _arity;
}

unsigned int FuncGenerator::binding() const {
	return _binding;
}

EnumeratedFuncGenerator::EnumeratedFuncGenerator(const set<Function*>& overfuncs)
		: 	FuncGenerator((*(overfuncs.cbegin()))->name(), (*(overfuncs.cbegin()))->arity(), (*(overfuncs.cbegin()))->binding()),
			_overfuncs(overfuncs) {
}

bool EnumeratedFuncGenerator::contains(const Function* function) const {
	for (auto it = _overfuncs.cbegin(); it != _overfuncs.cend(); ++it) {
		if ((*it)->contains(function)) {
			return true;
		}
	}
	return false;
}

/**
 * \brief Returns the unique function that is contained in the generator and that has the given sorts.
 * \brief Returns a null-pointer if such a function does not exist or is not unique
 */
Function* EnumeratedFuncGenerator::resolve(const vector<Sort*>& sorts) {
	Function* candidate = NULL;
	for (auto it = _overfuncs.cbegin(); it != _overfuncs.cend(); ++it) {
		Function* newcandidate = (*it)->resolve(sorts);
		if (newcandidate) {
			if (candidate and candidate != newcandidate) {
				return NULL;
			} else {
				candidate = newcandidate;
			}
		}
	}
	return candidate;
}

/**
 * \brief Returns the unique function that is contained in the generator and which sorts resolve with the given sorts.
 * \brief Returns a null-pointer if such a function does not exist or is not unique
 */
Function* EnumeratedFuncGenerator::disambiguate(const vector<Sort*>& sorts, const Vocabulary* vocabulary) {
	Function* candidate = NULL;
	for (auto it = _overfuncs.cbegin(); it != _overfuncs.cend(); ++it) {
		Function* newcandidate = (*it)->disambiguate(sorts, vocabulary);
		if (newcandidate) {
			if (candidate and candidate != newcandidate) {
				return NULL;
			} else {
				candidate = newcandidate;
			}
		}
	}
	return candidate;
}

set<Sort*> EnumeratedFuncGenerator::allsorts() const {
	set<Sort*> ss;
	for (auto it = _overfuncs.cbegin(); it != _overfuncs.cend(); ++it) {
		set<Sort*> os = (*it)->allsorts();
		ss.insert(os.cbegin(), os.cend());
	}
	ss.erase(0);
	return ss;
}

void EnumeratedFuncGenerator::addVocabulary(const Vocabulary* vocabulary) {
	for (auto it = _overfuncs.cbegin(); it != _overfuncs.cend(); ++it) {
		(*it)->addVocabulary(vocabulary);
	}
}

void EnumeratedFuncGenerator::removeVocabulary(const Vocabulary* vocabulary) {
	for (auto it = _overfuncs.begin(); it != _overfuncs.end();) {
		auto removed = (*it)->removeVocabulary(vocabulary);
		if (removed) {
			it = _overfuncs.erase(it);
		} else {
			++it;
		}
	}
}

set<Function*> EnumeratedFuncGenerator::nonbuiltins() const {
	set<Function*> sf;
	for (auto it = _overfuncs.cbegin(); it != _overfuncs.cend(); ++it) {
		set<Function*> temp = (*it)->nonbuiltins();
		sf.insert(temp.cbegin(), temp.cend());
	}
	return sf;
}

IntFloatFuncGenerator::IntFloatFuncGenerator(Function* intfunc, Function* floatfunc)
		: 	FuncGenerator(intfunc->name(), intfunc->arity(), intfunc->binding()),
			_intfunction(intfunc),
			_floatfunction(floatfunc) {
}

bool IntFloatFuncGenerator::contains(const Function* function) const {
	return (function == _intfunction || function == _floatfunction);
}

/**
 * Returns the integer function if the vector of sorts only contains int, 
 * the float function if it only contains float, and a null-pointer otherwise.
 */
Function* IntFloatFuncGenerator::resolve(const vector<Sort*>& sorts) {
	Assert(sorts.size() == 2 || sorts.size() == 3);
	if (sorts[0] == sorts[1] && (sorts.size() == 2 || sorts[1] == sorts[2])) {
		if (sorts[0] == get(STDSORT::INTSORT)) {
			return _intfunction;
		} else if (sorts[0] == get(STDSORT::FLOATSORT)) {
			return _floatfunction;
		} else {
			return NULL;
		}
	}
	return NULL;
}

/**
 * Returns a null-pointer if more than one of the sorts is a null-pointer, 
 * or one of the sorts that is not a null-pointer, is not a subsort of float.
 * Otherwise, return the integer function if all sorts are a subsort of int, 
 * and the float function if at least one sort is not a subsort of _int.
 */
Function* IntFloatFuncGenerator::disambiguate(const vector<Sort*>& sorts, const Vocabulary* vocabulary) {
	bool seennull = false;
	bool allints = true;
	auto intsort = get(STDSORT::INTSORT);
	auto floatsort = get(STDSORT::FLOATSORT);
	set<Sort*> seen;
	for (auto it = sorts.cbegin(); it != sorts.cend(); ++it) {
		if (*it == NULL) {
			if (seennull) {
				return NULL;
			}
			seennull = true;
			continue;
		}
		if (not seen.insert(*it).second) { // If not inserted, had already seen the sort, so prevent calling issubsort again!
			continue;
		}
		if (allints && not SortUtils::isSubsort(*it, intsort, vocabulary)) {
			allints = false;
		}
		if (not allints && not SortUtils::isSubsort(*it, floatsort, vocabulary)) {
			return NULL;
		}
	}
	return (allints ? _intfunction : _floatfunction);
}

/**
 * \brief Returns sorts int and float
 */
set<Sort*> IntFloatFuncGenerator::allsorts() const {
	return {get(STDSORT::INTSORT), get(STDSORT::FLOATSORT)};
}

void IntFloatFuncGenerator::addVocabulary(const Vocabulary* vocabulary) {
	_intfunction->addVocabulary(vocabulary);
	_floatfunction->addVocabulary(vocabulary);
}

void IntFloatFuncGenerator::removeVocabulary(const Vocabulary* vocabulary) {
	_intfunction->removeVocabulary(vocabulary);
	_floatfunction->removeVocabulary(vocabulary);
}

set<Function*> IntFloatFuncGenerator::nonbuiltins() const {
	set<Function*> sf;
	return sf;
}

OrderFuncGenerator::OrderFuncGenerator(const string& name, unsigned int arity, FuncInterGeneratorGenerator* inter)
		: 	FuncGenerator(name, arity, 0),
			_interpretation(inter) {
}

OrderFuncGenerator::~OrderFuncGenerator() {
	delete (_interpretation);
}

/**
 * \brief Returns true iff function has the same name as the generator, and all sorts of function are equal.
 */
bool OrderFuncGenerator::contains(const Function* function) const {
	if (function->name() == _name) {
		for (size_t n = 0; n < _arity; ++n) {
			if (function->outsort() != function->insort(n)) {
				return false;
			}
		}
		return true;
	} else {
		return false;
	}
}

/**
 * \brief Returns the unique function that has the name of the generator and the given sorts
 */
Function* OrderFuncGenerator::resolve(const vector<Sort*>& sorts) {
	for (size_t n = 1; n < sorts.size(); ++n) {
		if (sorts[n] != sorts[n - 1]) {
			return NULL;
		}
	}
	Assert(not sorts.empty());
	return disambiguate(sorts);
}

/**
 * \brief Returns the function F[A,...,A:A], where F is the name of the generator and A is the only sort 
 * \brief among the given sorts.
 */
Function* OrderFuncGenerator::disambiguate(const vector<Sort*>& sorts, const Vocabulary*) {
	Sort* funcSort = NULL;
	for (auto it = sorts.cbegin(); it != sorts.cend(); ++it) {
		if (*it != NULL) {
			if (funcSort != NULL) {
				if (funcSort != *it) {
					return NULL;
				}
			} else {
				funcSort = *it;
			}
		}
	}

	Function* func = NULL;
	if (funcSort != NULL) {
			vector<Sort*> funcSorts(_arity + 1, funcSort);
			func = new Function(_name, funcSorts, _interpretation->get(funcSorts), 0);
	}
	return func;
}

set<Sort*> OrderFuncGenerator::allsorts() const {
	set<Sort*> ss;
	return ss;
}

void OrderFuncGenerator::addVocabulary(const Vocabulary*) {
}

void OrderFuncGenerator::removeVocabulary(const Vocabulary*) {
}

set<Function*> OrderFuncGenerator::nonbuiltins() const {
	set<Function*> sf;
	return sf;
}

namespace FuncUtils {
Function* overload(Function* f1, Function* f2) {
	Assert(f1->name() == f2->name());
	if (f1 == f2) {
		return f1;
	}
	set<Function*> sf;
	sf.insert(f1);
	sf.insert(f2);
	return overload(sf);
}

Function* overload(const set<Function*>& sf) {
	if (sf.empty()) {
		return NULL;
	} else if (sf.size() == 1) {
		return *(sf.cbegin());
	} else {
		return new Function(new EnumeratedFuncGenerator(sf));
	}
}

bool isIntFunc(const Function* func, const Vocabulary* voc) {
	return SortUtils::isSubsort(func->outsort(), get(STDSORT::INTSORT), voc);
}

bool isIntSum(const Function* function, const Vocabulary* voc) {
	if (is(function, STDFUNC::ADDITION) || is(function, STDFUNC::SUBSTRACTION)) {
		bool allintsorts = isIntFunc(function, voc);
		for (auto it = function->insorts().cbegin(); it != function->insorts().cend(); ++it) {
			allintsorts *= SortUtils::isSubsort(*it, get(STDSORT::INTSORT), voc);
		}
		return allintsorts;
	}
	return false;
}

bool isIntProduct(const Function* function, const Vocabulary* voc) {
	if (is(function, STDFUNC::PRODUCT)) {
		bool allintsorts = isIntFunc(function, voc);
		for (auto it = function->insorts().cbegin(); it != function->insorts().cend(); ++it) {
			allintsorts *= SortUtils::isSubsort(*it, get(STDSORT::INTSORT), voc);
		}
		return allintsorts;
	}
	return false;
}

} /* FuncUtils */

/****************
 *	Vocabulary
 ***************/

Vocabulary::Vocabulary(const string& name)
		: 	_name(name),
			_namespace(0) {
	if (_name != "std") {
		add(Vocabulary::std());
	}
}

Vocabulary::Vocabulary(const string& name, const ParseInfo& pi)
		: 	_name(name),
			_pi(pi),
			_namespace(0) {
	if (_name != "std") {
		add(Vocabulary::std());
	}
}

Vocabulary::~Vocabulary() {
	if (this == _std) {
		_std = NULL;
	}
	for (auto it = _name2pred.cbegin(); it != _name2pred.cend(); ++it) {
		it->second->removeVocabulary(this);
	}
	for (auto it = _name2func.cbegin(); it != _name2func.cend(); ++it) {
		it->second->removeVocabulary(this);
	}
	for (auto it = _name2sort.cbegin(); it != _name2sort.cend(); ++it) {
		(*it).second->removeVocabulary(this);
	}
}

template<class Elem, class List>
void updateStructures(Elem elem, const List& structures) {
	for (auto i = structures.cbegin(); i != structures.cend(); ++i) {
		(*i)->notifyAddedToVoc(elem);
	}
}

void Vocabulary::add(Sort* s) {
	if (contains(s)) {
		return;
	}

	_name2sort[s->name()] = s;
	s->addVocabulary(this);
	for (auto p : s->parents()) {
		add(p);
	}
	updateStructures(s, structures);
	add(s->pred());
}

// TODO cleaner?
void Vocabulary::add(PFSymbol* symbol) {
	if (isa<Predicate>(*symbol)) {
		add(dynamic_cast<Predicate*>(symbol));
	} else {
		Assert(isa<Function>(*symbol));
		add(dynamic_cast<Function*>(symbol));
	}
}

void Vocabulary::add(Predicate* p) {
	if (contains(p)) {
		return;
	}
	if (p->type() != ST_NONE) {
		Warning::triedAddingSubtypeToVocabulary(p->name(), p->parent()->name(), this->name());
		add(p->parent());
	}

	if (_name2pred.find(p->name()) == _name2pred.cend()) {
		_name2pred[p->name()] = p;
	} else {
		auto ovp = PredUtils::overload(p, _name2pred[p->name()]);
		_name2pred[p->name()] = ovp;
		ovp->addVocabulary(this);
	}
	auto ss = p->allsorts();
	for (auto it = ss.cbegin(); it != ss.cend(); ++it) {
		add(*it);
	}
	p->addVocabulary(this);
	updateStructures(p, structures);
}

void Vocabulary::add(Function* f) {
	if (contains(f)) {
		return;
	}

	if (_name2func.find(f->name()) == _name2func.cend()) {
		_name2func[f->name()] = f;
	} else {
		auto ovf = FuncUtils::overload(f, _name2func[f->name()]);
		_name2func[f->name()] = ovf;
		ovf->addVocabulary(this);
	}
	auto ss = f->allsorts();
	for (auto it = ss.cbegin(); it != ss.cend(); ++it) {
		add(*it);
	}
	f->addVocabulary(this);
	updateStructures(f, structures);
}

void Vocabulary::add(Vocabulary* v) {
	for (auto it = v->firstSort(); it != v->lastSort(); ++it) {
		add((*it).second);
	}
	for (auto it = v->firstPred(); it != v->lastPred(); ++it) {
		add(it->second);
	}
	for (auto it = v->firstFunc(); it != v->lastFunc(); ++it) {
		add(it->second);
	}
}

Vocabulary* Vocabulary::_std = 0;
std::map<STDFUNC, std::string> func2string;
std::map<STDPRED, std::string> pred2string;
std::map<STDSORT, std::string> sort2string;

template<>
std::string getSymbolName(STDFUNC s) {
	if (func2string.empty()) {
		func2string[STDFUNC::UNARYMINUS] = "-/1";
		func2string[STDFUNC::ADDITION] = "+/2";
		func2string[STDFUNC::SUBSTRACTION] = "-/2";
		func2string[STDFUNC::PRODUCT] = "*/2";
		func2string[STDFUNC::DIVISION] = "//2";
		func2string[STDFUNC::ABS] = "abs/1";
		func2string[STDFUNC::MODULO] = "%/2";
		func2string[STDFUNC::EXPONENTIAL] = "^/2";
		func2string[STDFUNC::MINELEM] = "MIN/0";
		func2string[STDFUNC::MAXELEM] = "MAX/0";
		func2string[STDFUNC::SUCCESSOR] = "SUCC/1";
		func2string[STDFUNC::PREDECESSOR] = "PRED/1";
	}
	return func2string[s];
}

template<>
std::string getSymbolName(STDSORT s) {
	if (sort2string.empty()) {
		sort2string[STDSORT::NATSORT] = "nat";
		sort2string[STDSORT::INTSORT] = "int";
		sort2string[STDSORT::FLOATSORT] = "float";
		sort2string[STDSORT::CHARSORT] = "char";
		sort2string[STDSORT::STRINGSORT] = "string";
	}
	return sort2string[s];
}

template<>
std::string getSymbolName(STDPRED s) {
	if (pred2string.empty()) {
		pred2string[STDPRED::EQ] = "=/2";
		pred2string[STDPRED::GT] = ">/2";
		pred2string[STDPRED::LT] = "</2";
	}
	return pred2string[s];
}

Predicate* get(STDPRED type) {
	auto result = Vocabulary::std()->pred(getSymbolName(type));
	Assert(result!=NULL);
	Assert(result->builtin() || result->overloaded());
	return result;
}
Predicate* get(STDPRED type, Sort* sort) {
	auto result = Vocabulary::std()->pred(getSymbolName(type))->resolve( { sort, sort });
	Assert(result!=NULL);
	Assert(result->builtin());
	return result;
}
Function* get(STDFUNC type) {
	auto result = Vocabulary::std()->func(getSymbolName(type));
	Assert(result!=NULL);
	Assert(result->builtin() || result->overloaded());
	return result;
}
Function* getStdFunc(STDFUNC type, const std::vector<Sort*>& sorts, Vocabulary* voc) {
	return get(type,sorts,voc);
}
Function* get(STDFUNC type, const std::vector<Sort*>& sorts, Vocabulary* voc) {
	auto result = Vocabulary::std()->func(getSymbolName(type))->disambiguate(sorts, voc);
	Assert(result!=NULL);
	Assert(result->builtin());
	return result;
}
Sort* get(STDSORT type) {
	auto result = Vocabulary::std()->sort(getSymbolName(type));
	Assert(result!=NULL);
	Assert(result->builtin());
	return result;
}

Vocabulary* Vocabulary::std() {
	if (_std != NULL) {
		return _std;
	}

	_std = new Vocabulary("std");

	// Create sort interpretations
	auto allnats = new SortTable(new AllNaturalNumbers());
	auto allints = new SortTable(new AllIntegers());
	auto allfloats = new SortTable(new AllFloats());
	auto allstrings = new SortTable(new AllStrings());
	auto allchars = new SortTable(new AllChars());

	// Create sorts
	auto natsort = new Sort(getSymbolName(STDSORT::NATSORT), allnats);
	auto intsort = new Sort(getSymbolName(STDSORT::INTSORT), allints);
	auto floatsort = new Sort(getSymbolName(STDSORT::FLOATSORT), allfloats);
	auto charsort = new Sort(getSymbolName(STDSORT::CHARSORT), allchars);
	auto stringsort = new Sort(getSymbolName(STDSORT::STRINGSORT), allstrings);

	// Add the sorts
	_std->add(natsort);
	_std->add(intsort);
	_std->add(floatsort);
	_std->add(charsort);
	_std->add(stringsort);

	// Set sort hierarchy
	intsort->addParent(floatsort);
	natsort->addParent(intsort);
	charsort->addParent(stringsort);

	// Create predicate interpretations
	auto eqgen = new EqualInterGeneratorGenerator();
	auto ltgen = new StrLessThanInterGeneratorGenerator();
	auto gtgen = new StrGreaterThanInterGeneratorGenerator();

	// Create predicate overloaders
	auto eqpgen = new ComparisonPredGenerator(getSymbolName(STDPRED::EQ), eqgen);
	auto ltpgen = new ComparisonPredGenerator(getSymbolName(STDPRED::LT), ltgen);
	auto gtpgen = new ComparisonPredGenerator(getSymbolName(STDPRED::GT), gtgen);

	// Add predicates
	_std->add(new Predicate(eqpgen));
	_std->add(new Predicate(ltpgen));
	_std->add(new Predicate(gtpgen));

	// Create function interpretations
	Universe twoint(vector<SortTable*>(2, allints));
	Universe twofloat(vector<SortTable*>(2, allfloats));
	Universe threeint(vector<SortTable*>(3, allints));
	Universe threefloat(vector<SortTable*>(3, allfloats));

	auto modgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new ModInternalFuncTable(), threeint)));
	auto expgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new ExpInternalFuncTable(), threefloat)));

	vector<Sort*> twoints(2, intsort);
	vector<Sort*> twofloats(2, floatsort);
	vector<Sort*> threeints(3, intsort);
	vector<Sort*> threefloats(3, floatsort);

	auto intplusgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new PlusInternalFuncTable(true), threeint)));
	auto floatplusgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new PlusInternalFuncTable(false), threefloat)));
	auto intplus = new Function(getSymbolName(STDFUNC::ADDITION), threeints, intplusgen, 200);
	auto floatplus = new Function(getSymbolName(STDFUNC::ADDITION), threefloats, floatplusgen, 200);

	auto intminusgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new MinusInternalFuncTable(true), threeint)));
	auto floatminusgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new MinusInternalFuncTable(false), threefloat)));
	auto intminus = new Function(getSymbolName(STDFUNC::SUBSTRACTION), threeints, intminusgen, 200);
	auto floatminus = new Function(getSymbolName(STDFUNC::SUBSTRACTION), threefloats, floatminusgen, 200);

	auto inttimesgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new TimesInternalFuncTable(true), threeint)));
	auto floattimesgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new TimesInternalFuncTable(false), threefloat)));
	auto inttimes = new Function(getSymbolName(STDFUNC::PRODUCT), threeints, inttimesgen, 300);
	auto floattimes = new Function(getSymbolName(STDFUNC::PRODUCT), threefloats, floattimesgen, 300);

	//SingleFuncInterGenerator* intdivgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new DivInternalFuncTable(true), threeint)));
	auto floatdivgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new DivInternalFuncTable(false), threefloat)));
	//Function* intdiv = new Function("//2", threeints, intdivgen, 300);
	auto floatdiv = new Function(getSymbolName(STDFUNC::DIVISION), threefloats, floatdivgen, 300);
	floatdiv->partial(true);

	auto intabsgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new AbsInternalFuncTable(true), twoint)));
	auto floatabsgen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new AbsInternalFuncTable(false), twofloat)));
	auto intabs = new Function(getSymbolName(STDFUNC::ABS), twoints, intabsgen, 0);
	auto floatabs = new Function(getSymbolName(STDFUNC::ABS), twofloats, floatabsgen, 0);

	auto intumingen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new UminInternalFuncTable(true), twoint)));
	auto floatumingen = new SingleFuncInterGenerator(new FuncInter(new FuncTable(new UminInternalFuncTable(false), twofloat)));
	auto intumin = new Function(getSymbolName(STDFUNC::UNARYMINUS), twoints, intumingen, 500);
	auto floatumin = new Function(getSymbolName(STDFUNC::UNARYMINUS), twofloats, floatumingen, 500);

	auto minigengen = new MinInterGeneratorGenerator();
	auto maxigengen = new MaxInterGeneratorGenerator();
	auto succigengen = new SuccInterGeneratorGenerator();
	auto predigengen = new InvSuccInterGeneratorGenerator();

	// Create function overloaders
	auto plusgen = new IntFloatFuncGenerator(intplus, floatplus);
	auto minusgen = new IntFloatFuncGenerator(intminus, floatminus);
	auto timesgen = new IntFloatFuncGenerator(inttimes, floattimes);
	//IntFloatFuncGenerator* divgen = new IntFloatFuncGenerator(intdiv, floatdiv);
	auto absgen = new IntFloatFuncGenerator(intabs, floatabs);
	auto umingen = new IntFloatFuncGenerator(intumin, floatumin);
	auto mingen = new OrderFuncGenerator(getSymbolName(STDFUNC::MINELEM), 0, minigengen);
	auto maxgen = new OrderFuncGenerator(getSymbolName(STDFUNC::MAXELEM), 0, maxigengen);
	auto succgen = new OrderFuncGenerator(getSymbolName(STDFUNC::SUCCESSOR), 1, succigengen);
	auto predgen = new OrderFuncGenerator(getSymbolName(STDFUNC::PREDECESSOR), 1, predigengen);

	// Add functions
	auto modfunc = new Function(getSymbolName(STDFUNC::MODULO), threeints, modgen, 100);
	modfunc->partial(true);
	auto expfunc = new Function(getSymbolName(STDFUNC::EXPONENTIAL), threefloats, expgen, 400);
	_std->add(modfunc);
	_std->add(expfunc);
	_std->add(floatdiv);
	_std->add(new Function(plusgen));
	_std->add(new Function(minusgen));
	_std->add(new Function(timesgen));
	//_std->add(new Function(divgen));
	_std->add(new Function(absgen));
	_std->add(new Function(umingen));
	_std->add(new Function(mingen));
	_std->add(new Function(maxgen));
	_std->add(new Function(succgen));
	_std->add(new Function(predgen));

	return _std;
}

const string& Vocabulary::name() const {
	return _name;
}

const ParseInfo& Vocabulary::pi() const {
	return _pi;
}

bool Vocabulary::hasSortWithName(const std::string& name) const {
	return _name2sort.find(name) != _name2sort.cend();
}
bool Vocabulary::hasPredWithName(const std::string& name) const {
	return _name2pred.find(name) != _name2pred.cend();
}
bool Vocabulary::hasFuncWithName(const std::string& name) const {
	return _name2func.find(name) != _name2func.cend();
}

bool Vocabulary::contains(const Sort* s) const {
	auto it = _name2sort.find(s->name());
	if (it == _name2sort.cend()) {
		return false;
	}
	return it->second == s;
}

bool Vocabulary::contains(const Predicate* p) const {
	auto it = _name2pred.find(p->name());
	if (it != _name2pred.cend()) {
		return it->second->contains(p);
	} else {
		return false;
	}
}

bool Vocabulary::contains(const Function* f) const {
	auto it = _name2func.find(f->name());
	if (it != _name2func.cend()) {
		return it->second->contains(f);
	} else {
		return false;
	}
}

bool Vocabulary::contains(const PFSymbol* s) const {
	if (isa<Predicate>(*s)) {
		return contains(dynamic_cast<const Predicate*>(s));
	} else {
		Assert(isa<Function>(*s));
		return contains(dynamic_cast<const Function*>(s));
	}
}

std::vector<PFSymbol*> Vocabulary::getNonBuiltinNonOverloadedNonTypeSymbols() const {
		auto ret = std::vector<PFSymbol*>();
		for (auto symbol : getNonBuiltinNonOverloadedSymbols()) {
			if (VocabularyUtils::isTypePredicate(symbol)) {
				continue;
			}
			ret.push_back(symbol);
		}
		return ret;
	}

Sort* Vocabulary::sort(const string& name) const {
	auto it = _name2sort.find(name);
	if (it != _name2sort.cend()) {
		return it->second;
	} else {
		return NULL;
	}
}

Predicate* Vocabulary::pred(const string& name) const {
	auto it = _name2pred.find(name);
	if (it != _name2pred.cend()) {
		return it->second;
	} else {
		return 0;
	}
}

Function* Vocabulary::func(const string& name) const {
	auto it = _name2func.find(name);
	if (it != _name2func.cend()) {
		return it->second;
	} else {
		return 0;
	}
}

set<Predicate*> Vocabulary::pred_no_arity(const string& name) const {
	set<Predicate*> vp;
	for (auto it = _name2pred.cbegin(); it != _name2pred.cend(); ++it) {
		string nm = it->second->name();
		if (nm.substr(0, nm.rfind('/')) == name) {
			vp.insert(it->second);
		}
	}
	return vp;
}

set<Function*> Vocabulary::func_no_arity(const string& name) const {
	set<Function*> vf;
	for (auto it = _name2func.cbegin(); it != _name2func.cend(); ++it) {
		string nm = it->second->name();
		if (nm.substr(0, nm.rfind('/')) == name) {
			vf.insert(it->second);
		}
	}
	return vf;
}

ostream& Vocabulary::putName(ostream& output) const {
	if (_namespace && not _namespace->isGlobal()) {
		_namespace->putName(output);
		output << "::";
	}
	output << _name;
	return output;
}

ostream& Vocabulary::put(ostream& output) const {
	auto printer = Printer::create(output);
	printer->startTheory();
	printer->print(this);
	printer->endTheory();
	return output;
}

ostream& operator<<(ostream& output, const Vocabulary& voc) {
	return voc.put(output);
}

namespace VocabularyUtils {
bool isPredicate(const PFSymbol* symbol, STDPRED predtype){
	return isa<Predicate>(*symbol) && is(symbol, predtype);
}

bool isFunction(const PFSymbol* symbol, STDFUNC functype){
	return isa<Function>(*symbol) && is(symbol, functype);
}

bool isTypePredicate(const PFSymbol* symbol) {
    	return (isa<Predicate>(*symbol) and PredUtils::isTypePredicate(dynamic_cast<const Predicate*>(symbol)));
}


bool isComparisonPredicate(const PFSymbol* symbol) {
	return isPredicate(symbol, STDPRED::EQ) || isPredicate(symbol, STDPRED::LT) || isPredicate(symbol, STDPRED::GT);
}

CompType getComparisonType(const PFSymbol* symbol) {
	Assert(isComparisonPredicate(symbol));
	if (is(symbol, STDPRED::EQ)) {
		return CompType::EQ;
	}
	if (is(symbol, STDPRED::LT)) {
		return CompType::LT;
	} else {
		Assert(is(symbol, STDPRED::GT));
		return CompType::GT;
	}
}

bool isIntComparisonPredicate(const PFSymbol* symbol, const Vocabulary* voc) {
	string name = symbol->name();
	if (isComparisonPredicate(symbol)) {
		for (auto it = symbol->sorts().cbegin(); it != symbol->sorts().cend(); ++it) {
			if (not SortUtils::isSubsort(*it, get(STDSORT::INTSORT), voc)) {
				return false;
			}
		}
		return true;
	}
	return false;
}

bool isIntPredicate(const PFSymbol* symbol, const Vocabulary* voc) {
	for (auto sort : symbol->sorts()) {
		if (not SortUtils::isSubsort(sort, get(STDSORT::INTSORT), voc)) {
			return false;
		}
	}
	return true;
}

bool isNumeric(Sort* s) {
	return SortUtils::isSubsort(s, get(STDSORT::FLOATSORT));
}

bool isConstructorFunction(const PFSymbol* symbol) {
	return isa<Function>(*symbol) and dynamic_cast<const Function*>(symbol)->isConstructorFunction();
}

bool isSubVocabulary(Vocabulary* child, Vocabulary* parent) {
	if (parent == child || child == NULL) {
		return true;
	}
	if (parent == NULL) {
		return false;
	}
	// cv = childvoc, pv = parentvoc
	std::map<Sort*, Sort*> cv2pvsort;
	for (auto it = child->firstSort(); it != child->lastSort(); ++it) {
		auto childsort = it->second;
		auto parentsort = parent->sort(childsort->name());
		if (parentsort == NULL || parentsort->parents().size() != childsort->parents().size()) {
			return false;
		}
		cv2pvsort[childsort] = parentsort;
	}
	for (auto c2p : cv2pvsort) {
		auto cvsort = c2p.first;
		auto pvsort = c2p.second;
		for (auto cvparent : cvsort->parents()) {
			auto childparentit = cv2pvsort.find(cvparent);
			if (childparentit == cv2pvsort.cend()) {
				return false;
			}
			bool found = false;
			for (auto k = pvsort->parents().cbegin(); k != pvsort->parents().cend(); ++k) {
				if (*k == childparentit->second) {
					found = true;
				}
			}
			if (not found) {
				return false;
			}
		}
	}
	for (auto pred : child->getPreds()) {
		auto generalchildpred = pred.second;
		if (generalchildpred->builtin()) {
			continue;
		}
		auto allpreds = generalchildpred->nonbuiltins();
		for (auto childpred : allpreds) {
			Assert(not childpred->overloaded());
			auto parentpred = parent->pred(childpred->name());
			if (parentpred == NULL) {
				return false;
			}
			std::vector<Sort*> mappedsorts;
			for (auto k = childpred->sorts().cbegin(); k < childpred->sorts().cend(); ++k) {
				auto sortit = cv2pvsort.find(*k);
				if (sortit == cv2pvsort.cend()) {
					return false;
				}
				mappedsorts.push_back(sortit->second);
			}
			if (parentpred->disambiguate(mappedsorts) == NULL) {
				return false;
			}
		}
	}
	for (auto i = child->firstFunc(); i != child->lastFunc(); ++i) {
		auto generalchildfunc = i->second;
		if (generalchildfunc->builtin()) {
			continue;
		}
		auto allfuncs = generalchildfunc->nonbuiltins();
		for (auto j = allfuncs.cbegin(); j != allfuncs.cend(); ++j) {
			auto childfunc = *j;
			Assert(not childfunc->overloaded());
			auto parentfunc = parent->func(childfunc->name());
			if (parentfunc == NULL) {
				return false;
			}
			std::vector<Sort*> mappedsorts;
			for (auto k = childfunc->sorts().cbegin(); k < childfunc->sorts().cend(); ++k) {
				auto sortit = cv2pvsort.find(*k);
				if (sortit == cv2pvsort.cend()) {
					return false;
				}
				mappedsorts.push_back(sortit->second);
			}
			auto disambigfunc = parentfunc->disambiguate(mappedsorts, parent);
			if (disambigfunc == NULL) {
				return false;
			}
			if (disambigfunc->partial() != childfunc->partial()) {
				return false;
			}
		}
	}
	return true;
}

bool containsSymbol(string name, int arity, Vocabulary::Symbol sym, const Vocabulary* voc) {
	std::stringstream sstm;
	sstm << name.substr(0, name.rfind('/')) << "/" << arity;
	auto newname = sstm.str();
	return (VocabularyUtils::getSymbol(voc, sym, newname) != NULL);
}
PFSymbol* getSymbol(const Vocabulary* voc, Vocabulary::Symbol sym, string name) {
	if (sym == Vocabulary::Symbol::PREDICATE) {
		return voc->pred(name);
	} else {
		return voc->func(name);
	}
}

} /* VocabularyUtils */
