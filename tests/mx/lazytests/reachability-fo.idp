#include <mx>

vocabulary V{
	type Vtx
	Edge(Vtx,Vtx)
	Reaches(Vtx,Vtx) //the query

	Connected
	Path(Vtx, Vtx)
	L(Vtx, Vtx, int)
	R1(Vtx, Vtx)
	R2(Vtx, Vtx)
	ValidLevel(Vtx, Vtx)
}
theory T:V{
	!a x: Path(a, x) <=> R1(a, x) | R2(a, x).
	!a x: R1(a, x) <=> Edge(a, x) & L(a, x, 0).
	!a x: R2(a, x) <=> Path(a, y) & Edge(y, x) & ValidLevel(a, x) /* & ?l: L(a, x, l)*/.
	//!a x l1 l2: ValidLevel(a, x) & L(a, x, l1) & L(a, y, l2) => l1=l2+1. 
	Connected <=> ?a b: Reaches(a,b) & Path(a,b).
}

procedure main(){
	stdoptions.groundlazily=true
	stdoptions.groundwithbounds=true
	stdoptions.groundverbosity=1
	stdoptions.satverbosity=1
	sol = modelexpandpartial(T, S)
	mx::printtuples("Connected", sol[V::Connected].ct)
	mx::printtuples("Connected", sol[V::Connected].cf)
	mx::printtuples("Path", sol[V::Path].ct)
	mx::printtuples("Path", sol[V::Path].cf)
}

structure S:V{