#include <mx>
#include <table_utils>

vocabulary V{
	type Vtx
	Edge(Vtx,Vtx)
	Reaches(Vtx,Vtx) //the query

	Connected
	Path(Vtx, Vtx)
	L(Vtx, Vtx, nat)
	R2(Vtx, Vtx)
}
theory T:V{
	!a x: Path(a, x) <=> Edge(a, x) | ?y: Path(a, y) & Edge(y, x).
	!a x y: Reaches(a, y) & Path(a, x) => (Edge(a, x) & L(a, x, 0)) | R2(a, x). // Remaining issue: grounds this completely as it cannot be delayed
	//!a x: R2(a, x) => ?l: L(a, x, l).
	//!a x l l2: L(a, x, l) & L(a, x, l2) => l=l2.
	
	//!a x y l l2: L(a, x, l) & L(a, y, l2) & R2(a, x) & Edge(y, x) & Path(a, y) & Path(a, x) => l>l2.

	Connected <=> ?a b: Reaches(a,b) & Path(a,b).
}

procedure main(){
	stdoptions.groundlazily=true
	stdoptions.groundwithbounds=true
	stdoptions.groundverbosity=2
	stdoptions.verbosity.solving=1
	sol = modelexpandpartial(T, S)
	mx::printtuples("Connected<ct>", sol[V::Connected].ct)
	mx::printtuples("Connected<cf>", sol[V::Connected].cf)
	mx::printtuples("Path<ct>", sol[V::Path].ct)
	mx::printtuples("Path<cf>", sol[V::Path].cf)
	mx::printtuples("L<ct>", sol[V::L].ct)
	mx::printtuples("L<cf>", sol[V::L].cf)
}

structure S:V{