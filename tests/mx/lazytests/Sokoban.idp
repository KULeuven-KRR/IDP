vocabulary V{
	type Loc
	type Step isa int
	type Dir
	Right:Dir
	Left:Dir
	Up:Dir
	Down:Dir

	Right(Loc,Loc)
	Top(Loc,Loc)
	Sokoban(Loc)
	Solution(Loc)
	Box(Loc)

	// Additional
	Sok(Loc,Step)
	BoxT(Loc,Step)
	Reachable (Loc, Step)
	Start(Step) 
	End(Step)
	NextDir(Loc,Dir,Loc)
	Linear(Loc,Dir,Loc)
	Corner(Loc)

	// Find
	Push(Loc,Dir,Loc,Step)
}
theory T:V{
	{ Start(MIN[:Step]). }
	{ End(MAX[:Step]). }
	
	// Directed neighbour positions
	!l d l1: NextDir(l, d, l1) <=> (d=Right & Right(l,l1)) | (d=Left & Right(l1,l)) | (d=Up & Top(l,l1)) | (d=Down & Top(l1,l)).
	//{  NextDir(l,Right,l1) <- Right(l,l1).
	//	NextDir(l,Left,l1) <- Right(l1,l).
	//	NextDir(l,Up,l1) <- Top(l,l1).
	//	NextDir(l,Down,l1) <- Top(l1,l).  
	//}

	// Linear(x,d,y) is the transitive closure of NextDir
	!x d y: Linear(x,d,y) <=> (NextDir(x,d,y) | (?x1: NextDir(x,d,x1) & Linear(x1,d,y))).
	//{  Linear(x,d,y) <- NextDir(x,d,y).
	//	Linear(x,d,y) <- NextDir(x,d,x1) & Linear(x1,d,y). 
	//}

	// position of the sokoban and the blocks
	!x t: Sok(x,t) <=> ((Start(t) & Sokoban(x)) | (Step(t-1) & ?u d v: Push(u,d,v,t-1) & NextDir(x,d,v))).
	/*{  
		Sok(x,t) <- Start(t) & Sokoban(x).
		Sok(x,t) <- Push(u,d,v,t-1) & NextDir(x,d,v).
	}*/
	!x t: BoxT(x,t) <=> ((Start(t) & Box(x)) | (Step(t-1) & ?y d: Push(y,d,x,t-1)) | (Step(t-1) & BoxT(x,t-1) & ~(?d y: Push(x,d,y,t-1)))).
	/*{
		BoxT(x,t) <- Start(t) & Box(x). 
		BoxT(y,t) <- Push(x,d,y,t-1).
		BoxT(x,t) <- BoxT(x,t-1) & ~ (? d y : Push(x,d,y,t-1)).
	}*/

	// one Push per timestep
	! t x1 d1 y1: Push(x1,d1,y1,t) => !x2 d2 y2: Push(x2,d2,y2,t) => x1=x2 & d1=d2 & y1=y2.
	! t : End(t)  => ~ (? x d y : Push(x,d,y,t)).

	! t x d y : Push(x,d,y,t) => ?x1: NextDir(x1,d,x) & Reachable(x1,t).

	{  Reachable(l,t) <- Sok(l,t).
		Reachable(l,t) <- ~BoxT(l,t) & ? l1 : Reachable(l1,t) & ? d: NextDir(l1,d,l). 
	}

	//  A push-trajectory is linear.  
	! x d y t : Push(x,d,y,t) => x=y | Linear(x,d,y).

	//  A push-trajectory   over free locations:
	! x d y t : Push(x,d,y,t) =>  (! z: Linear(x,d,z)  & (z=y | Linear(z,d,y)) => ~BoxT(z,t)). 

	// goal
	! t: End(t) => (!x: BoxT(x,t)  => Solution(x)).
}
structure Test1:V{
	Dir = {A..D} Up=A Left=B Right=C Down=D
	Step = {1..2}
	Loc = {1..4;}
	Top = {}
	Right = {1,2;2,3;3,4}
	Solution = {4}
	Box = {2}
	Sokoban = {1}
}
structure Test2:V{
	Dir = {A..D} Up=A Left=B Right=C Down=D
	Step = {1..3	}
	Loc = {1..5;6;7}
	Top = {4,3;5,4;2,6;3,7;}
	Right = {1,2;2,3;6,7}
	Solution = {5}
	Box = {2}
	Sokoban = {1}
}
structure Test3:V{
	Dir = {A..D} Up=A Left=B Right=C Down=D
	Step = {1..2}
	Loc = {1..41;}
	Top = {}
	Right = {1,2;2,3;3,4;4,5;5,6;6,7;7,8;8,9;9,10;10,11;11,12;12,13;13,14;14,15;15,16;16,17;17,18;18,19;19,20;20,21;21,22;
		22,23;23,24;24,25;25,26;26,27;27,28;28,29;29,30;30,31;31,32;32,33;33,34;34,35;35,36;36,37;37,38;38,39;39,40;40,41;
//		41,42;42,43;43,44;44,45;45,46;46,47;47,48;48,49;49,50;50,51;51,52;52,53;53,54;54,55;55,56;56,57;57,58;58,59;59,60;
//		60,61;61,62;62,63;63,64;64,65;65,66;66,67;67,68;68,69;69,70;70,71;71,72;72,73;73,74;74,75;75,76;76,77;77,78;78,79;
//		79,80;80,81;81,82;82,83;83,84;84,85;85,86;86,87;87,88;88,89;89,90;90,91;91,92;92,93;93,94;94,95;95,96;96,97;97,98;
//		98,99;99,100;
	}
	Solution = {41}
	Box = {20}
	Sokoban = {1}
}
procedure main(inputfilename, lazy){
	inputfile = io.open(inputfilename, "r")
	file = io.open("test", "w")
	file:write("structure S:V{")
	file:write("Dir = {A..D}")
	file:write("Up=A ")
	file:write("Left=B ")
	file:write("Right=C ")
	file:write("Down=D ")
	file:write(inputfile:read("*all"))
	file:write("}")
	file:close()
	parse("test")
	stdoptions.groundverbosity=1
	stdoptions.satverbosity=1
	stdoptions.groundlazily=lazy
	stdoptions.groundwithbounds=true
	sol = modelexpandpartial(T,Test3)
	print(sol)
	os.remove("test")
}

