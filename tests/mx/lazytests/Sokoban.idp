vocabulary V{
	type Loc
	type Step isa int
	type Dir
	Right:Dir
	Left:Dir
	Up:Dir
	Down:Dir

	Right(Loc,Loc)
	Top(Loc,Loc)
	Sokoban(Loc)
	Solution(Loc)
	Box(Loc)

	// Additional
	Sok(Loc,Step)
	BoxT(Loc,Step)
	Reachable (Loc, Step)
	Start(Step) 
	End(Step)
	NextDir(Loc,Dir,Loc)
	Linear(Loc,Dir,Loc)
	Corner(Loc)

	// Find
	Push(Loc,Dir,Loc,Step)
}
theory T:V{
	{ Start(MIN[:Step]). }
	{ End(MAX[:Step]). }
	
	// Directed neighbour positions
	!l d l1: NextDir(l, d, l1) <=> (d=Right & Right(l,l1)) | (d=Left & Right(l1,l)) | (d=Up & Top(l,l1)) | (d=Down & Top(l1,l)).
	//{  NextDir(l,Right,l1) <- Right(l,l1).
	//	NextDir(l,Left,l1) <- Right(l1,l).
	//	NextDir(l,Up,l1) <- Top(l,l1).
	//	NextDir(l,Down,l1) <- Top(l1,l).  
	//}

	// Linear(x,d,y) is the transitive closure of NextDir
	!x d y: Linear(x,d,y) <=> (NextDir(x,d,y) | (?x1: NextDir(x,d,x1) & Linear(x1,d,y))).
	//{  Linear(x,d,y) <- NextDir(x,d,y).
	//	Linear(x,d,y) <- NextDir(x,d,x1) & Linear(x1,d,y). 
	//}

	// position of the sokoban and the blocks
	!x t: Sok(x,t) <=> ((Start(t) & Sokoban(x)) | (Step(t-1) & ?u d v: Push(u,d,v,t-1) & NextDir(x,d,v))).
	/*{  
		Sok(x,t) <- Start(t) & Sokoban(x).
		Sok(x,t) <- Push(u,d,v,t-1) & NextDir(x,d,v).
	}*/
	!x t: BoxT(x,t) <=> ((Start(t) & Box(x)) | (Step(t-1) & ?y d: Push(y,d,x,t-1)) | (Step(t-1) & BoxT(x,t-1) & ~(?d y: Push(x,d,y,t-1)))).
	/*{
		BoxT(x,t) <- Start(t) & Box(x). 
		BoxT(y,t) <- Push(x,d,y,t-1).
		BoxT(x,t) <- BoxT(x,t-1) & ~ (? d y : Push(x,d,y,t-1)).
	}*/

	// one Push per timestep
	! t x1 d1 y1: Push(x1,d1,y1,t) => !x2 d2 y2: Push(x2,d2,y2,t) => x1=x2 & d1=d2 & y1=y2.
	! t : End(t)  => ~ (? x d y : Push(x,d,y,t)).

	! t x d y : Push(x,d,y,t) => ?x1: NextDir(x1,d,x) & Reachable(x1,t).

	{  Reachable(l,t) <- Sok(l,t).
		Reachable(l,t) <- ~BoxT(l,t) & ? l1 : Reachable(l1,t) & ? d: NextDir(l1,d,l). 
	}

	//  A push-trajectory is linear.  
	! x d y t : Push(x,d,y,t) => x=y | Linear(x,d,y).

	//  A push-trajectory over free locations:
	! x d y t : Push(x,d,y,t) => (! z: Linear(x,d,z)  & (z=y | Linear(z,d,y)) => ~BoxT(z,t)). 

	// goal
	! t: End(t) => (!x: BoxT(x,t)  => Solution(x)).
}
procedure main(inputfilename, lazy){
	inputfile = io.open(inputfilename, "r")
	file = io.open("test", "w")
	file:write("structure S:V{")
	file:write("Dir = {A..D}")
	file:write("Up=A ")
	file:write("Left=B ")
	file:write("Right=C ")
	file:write("Down=D ")
	file:write(inputfile:read("*all"))
	file:write("}")
	file:close()
	parse("test")
	stdoptions.groundverbosity=1
	stdoptions.verbosity.solving=1
	stdoptions.groundlazily=lazy
	stdoptions.groundwithbounds=false
	sol = modelexpandpartial(T,S)
	print(sol)
	os.remove("test")
}

