vocabulary V{
	type partition
	type number isa int
	in(partition, number)
}

theory T: V{
	!n: ?p: in(p, n).
	!p n: in(p, n) => !p2: in(p2, n) => p=p2.
	//!p n: in(p, n) => ?n2: n~=n2 & in(p, n2).
}

structure S: V {
	partition = {1..$p}
	number = {1..$n}
}

// works great for large n and small p, certainly if it chooses false for atoms by default.

#include <mx>

procedure getasol(lazy){
	stdoptions.groundlazily=lazy
	stdoptions.groundwithbounds=true
	stdoptions.verbosity.grounding=1
	stdoptions.verbosity.solving=1
	//stdoptions.symmetry=1 only for non-builtin types!
	return modelexpandpartial(T, S, stdoptions)
}

procedure run(lazy){
	sol = getasol(lazy)
	//print(sol)
}

procedure main(){
	run(true)
}
