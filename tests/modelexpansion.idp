include <mx>

procedure standardoptions(){
	stdoptions.verbosity.solving=0
	stdoptions.verbosity.grounding=0
	stdoptions.verbosity.transformations=0
	stdoptions.verbosity.creategrounders=0
	stdoptions.groundwithbounds=true
	stdoptions.liftedunitpropagation=true
	stdoptions.satdelay=false
	stdoptions.tseitindelay=false
	stdoptions.lazyheur=false
	stdoptions.xsb=false
  	stdoptions.approxdef="none"
}

procedure mxnobounds(){
	stdoptions.groundwithbounds = false	
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 7
	return run(T)
}

// NOTE: only based on lazy tseitin delaying!!!!
// NOTE: never enable delaying here which depends on well-founded definitions!
procedure mxlazy(){
	stdoptions.tseitindelay = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxlazycp(){
	stdoptions.cpsupport = true
	stdoptions.tseitindelay = true
	stdoptions.timeout = 7
	return run(T)
}

// NOTE: never enable delaying here which depends on well-founded definitions!
procedure mxverylazy(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation=false
	stdoptions.lazyheur=true
	stdoptions.relevancewatched=true
	stdoptions.existsexpansion=2
	stdoptions.lazysizelimit=3
	stdoptions.satdelay=true
	stdoptions.tseitindelay=true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxfuncdetect(){
	stdoptions.timeout = 100
	stdoptions.verbosity.functiondetection=0
	stdoptions.verbosity.entails=0
	newT = detectfunctions(clone(T))
	setvocabulary(S,getvocabulary(newT))
	return run(newT)
}

procedure mxnoboundslong(){
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 200
	return run(T)
}

procedure mxwithbounds(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithxsb(){
	stdoptions.xsb=true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithapproxdefs(){
	stdoptions.xsb=true
  	stdoptions.approxdef="cheap"
  	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithboundswithoutLUP(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 7
	return run(T)
}

procedure mxnonreduced(){
	stdoptions.reducedgrounding = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithcp(){
	stdoptions.cpsupport = true
	stdoptions.gecode = false
	stdoptions.cpgroundatoms = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithcpgecode(){
	stdoptions.cpsupport = true
	stdoptions.gecode = true
	stdoptions.cpgroundatoms = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithfullcp(){
	stdoptions.cpsupport = true
	stdoptions.cpgroundatoms = true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}


procedure mxwithSharedTseitins(){
	stdoptions.sharedtseitins = true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 7
	return run(T)
}

procedure mxwithsymm(){
	stdoptions.timeout = 7
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.symmetrybreaking = "static"
	
	stdoptions.showwarnings = false // Do not print warnings that more models MIGHT exist
	
	stdoptions.nbmodels = getExpectedNbOfModels()+1 // NOTE: prevents finding tons of models and timing out when bugs are present
	solutions = modelexpand(T, S, Vout)
	standardoptions()
	
	if(#solutions>getExpectedNbOfModels()) then
		io.stderr:write("Found more than "..getExpectedNbOfModels().." models.\n")
		return 0
	else
		io.stderr:write("Found "..#solutions..", expected "..getExpectedNbOfModels().." models.\n")
		return check(solutions)
	end
}

procedure mxCardFO(){
	newT = clone(T)
	removecardinalities(newT,10)
	return run(newT)
}

procedure run(theory) {
	if(allowed~=nil) then
		if (not allowed()) then 
			print("NOT running this test in this context!")
			return 1
		end
	end
	
	stdoptions.verbosity.solving=0
	stdoptions.verbosity.grounding=0
	stdoptions.verbosity.transformations=0
	stdoptions.verbosity.creategrounders=0
	
	stdoptions.mxtimeout = 2000
	
	stdoptions.nbmodels = getExpectedNbOfModels()+1 // NOTE: prevents finding tons of models and timing out when bugs are present
	solutions = modelexpand(theory, S, Vout)
	io.stderr:write("MX done\n")
	standardoptions()
	if(#solutions~=getExpectedNbOfModels()) then
		if(#solutions>getExpectedNbOfModels()) then
			io.stderr:write("Found more than "..getExpectedNbOfModels().." models.\n")
		else
			io.stderr:write("Found "..#solutions..", expected "..getExpectedNbOfModels().." models.\n") 
		end
		for i,v in ipairs(solutions) do
			io.stderr:write(tostring(v))
		end
		check(solutions)
		return 0
	else
		io.stderr:write("Found "..#solutions..", expected "..getExpectedNbOfModels().." models.\n")
		return check(solutions)
	end	
}

procedure check(solutions){
	//avoid bootstrapping code while checking (too expensive to do it over and over again)
	stdoptions.postprocessdefs = false
	stdoptions.splitdefs = false
	if(shouldNotCheck~=nil) then
		print("NOTE: solutions unchecked because too expensive!")
		return 1;
	end
	for i,v in ipairs(solutions) do
		structure = v
		if(Vout~=nil and Vout~=V)then
			setvocabulary(v,V)
			structure = merge(S,v)
		end
		mergedS = merge(S,structure)
		if(not isconsistent(mergedS) or not value(T, structure)) then
			io.stderr:write("Found an invalid solution:\n")
			io.stderr:write(tostring(v))
			return 0
		end
	end
	return 1
}
procedure checkmodelsandnonmodels() {
	if(shouldNotCheck~=nil) then
		print("NOTE: models unchecked because too expensive!")
		return 1;
	end
	stdoptions.verbosity.solving=0
	stdoptions.verbosity.grounding=0
	stdoptions.timeout=10 //Higher timeout since lots of checks here
	stdoptions.nbmodels=0
	structures = nbModelsTwoValuedExtensions(S)
	models = {}
	nonmodels = {}
	for i,structure in ipairs(structures) do
		if(#modelexpand(T, structure, Vout)==1) then
			table.insert(models,structure)
		else
			table.insert(nonmodels,structure)
		end
	end
	if(#models > getExpectedNbOfModels()) then
		io.stderr:write("At least one of these is not a model, but was not detected as such.\n")
		for i,structure in ipairs(models) do
			io.stderr:write(tostring(structure))
		end
		return 0
	elseif(#models < getExpectedNbOfModels()) then
		io.stderr:write("At least one of these is a model, but was not detected as such.\n")
		for i,structure in ipairs(nonmodels) do
			io.stderr:write(tostring(structure))
		end
		return 0
	end
	return 1
}

procedure nbmodelsOptionVerification() {
	if getExpectedNbOfModels()<2 then return 1; end
	stdoptions.nbmodels = getExpectedNbOfModels()-1
	solutions = modelexpand(T, S, Vout)
	if(#solutions==getExpectedNbOfModels()-1) then
		return 1
	else 
		return 0
	end
}
