#include <mx>

procedure mxnobounds(){
	stdoptions.groundwithbounds = false
	stdoptions.timeout = 5
	return run()
}

procedure mxlazy(){
	stdoptions.groundwithbounds = false
	stdoptions.groundlazily = true
	stdoptions.tseitindelay = true
	// NOTE: never enable delaying here which depends on well-founded definitions!
	stdoptions.timeout = 5
	return run()
}

procedure mxnoboundslong(){
	stdoptions.groundwithbounds = false
	stdoptions.timeout = 200
	return run()
}

procedure mxwithbounds(){
	stdoptions.groundwithbounds = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithcp(){
	stdoptions.cpsupport = true
	stdoptions.groundwithbounds = true
	stdoptions.timeout = 5
	return run()
}


procedure mxwithSharedTseitins(){
	stdoptions.sharedtseitins = true
	stdoptions.groundwithbounds = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithsymm(){
	stdoptions.timeout = 5
	stdoptions.groundwithbounds = false
	stdoptions.symmetrybreaking = "static"
	stdoptions.showwarnings = false //Avoid printing all warnings taht more models MIGHT exist
	stdoptions.nbmodels = 0
	solutions = allmodels(T,S)
	io.stderr:write("Found "..#solutions.." models, expected at most "..getExpectedNbOfModels().." models.\n")
	if(#solutions>getExpectedNbOfModels()) then
		return 0
	end 
	
	return check(solutions)
}

procedure run() {
	stdoptions.nbmodels = 0
	solutions = allmodels(T,S)
	io.stderr:write("Found "..#solutions.." models, expected "..getExpectedNbOfModels().." models.\n")
	if(#solutions~=getExpectedNbOfModels()) then
		return 0
	end 
	return check(solutions)
}

procedure check(solutions){
local k  = 0
	for i,v in ipairs(solutions) do
		k = k +1
		if( k <5 and #modelexpand(T, v)==0) then
			io.stderr:write("Found an invalid solution.\n")
			return 0
		end
	end
	return 1

}
