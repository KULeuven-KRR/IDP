include <mx>

procedure mxnobounds(){
	stdoptions.groundwithbounds = false	
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 5
	return run()
}

// NOTE: only based on lazy tseitin delaying!!!!
// NOTE: never enable delaying here which depends on well-founded definitions!
procedure mxlazy(){
	stdoptions.tseitindelay = true
	stdoptions.groundwithbounds=true
	stdoptions.liftedunitpropagation=true
	stdoptions.timeout = 5
	return run()
}

procedure mxlazycp(){
	stdoptions.cpsupport = true
	stdoptions.tseitindelay = true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

// NOTE: never enable delaying here which depends on well-founded definitions!
procedure mxverylazy(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation=false
	stdoptions.lazyheur=true
	stdoptions.relevancewatched=true
	stdoptions.existsexpansion=2
	stdoptions.lazysizelimit=3
	stdoptions.satdelay=true
	stdoptions.tseitindelay=true
	stdoptions.timeout = 5
	return run()
}

procedure mxnoboundslong(){
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 200
	return run()
}

procedure mxwithbounds(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithxsb(){
	stdoptions.xsb=true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithboundswithoutLUP(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 5
	return run()
}

procedure mxnonreduced(){
	stdoptions.reducedgrounding = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithcp(){
	stdoptions.cpsupport = true
	stdoptions.gecode = false
	stdoptions.cpgroundatoms = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithcpgecode(){
	stdoptions.cpsupport = true
	stdoptions.gecode = true
	stdoptions.cpgroundatoms = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithfullcp(){
	stdoptions.cpsupport = true
	stdoptions.cpgroundatoms = true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}


procedure mxwithSharedTseitins(){
	stdoptions.sharedtseitins = true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 5
	return run()
}

procedure mxwithsymm(){
	stdoptions.timeout = 5
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.symmetrybreaking = "static"
	stdoptions.showwarnings = false // Do not print warnings that more models MIGHT exist
	stdoptions.nbmodels = getExpectedNbOfModels()+1
	solutions = modelexpand(T, S, Vout)
	if(#solutions>getExpectedNbOfModels()) then
		io.stderr:write("Found more than "..getExpectedNbOfModels().." models.\n")
		return 0
	else
		io.stderr:write("Found "..#solutions..", expected "..getExpectedNbOfModels().." models.\n")
		return check(solutions)
	end 	
}

procedure run() {
	stdoptions.verbosity.solving=0
	stdoptions.verbosity.grounding=0
	stdoptions.verbosity.transformations=0
	stdoptions.verbosity.creategrounders=0
	stdoptions.nbmodels = getExpectedNbOfModels()+1 // NOTE: prevents finding tons of models and timing out when bugs are present
	solutions = modelexpand(T, S, Vout)
	io.stderr:write("MX done")
	stdoptions.verbosity.solving=0
	stdoptions.verbosity.grounding=0
	stdoptions.groundwithbounds=true
	stdoptions.liftedunitpropagation=true
	stdoptions.satdelay=false
	stdoptions.tseitindelay=false
	stdoptions.lazyheur=false
	if(#solutions~=getExpectedNbOfModels()) then
		if(#solutions>getExpectedNbOfModels()) then
			io.stderr:write("Found more than "..getExpectedNbOfModels().." models.\n")
		else
			io.stderr:write("Found "..#solutions..", expected "..getExpectedNbOfModels().." models.\n") 
		end
		for i,v in ipairs(solutions) do
			io.stderr:write(tostring(v))
		end
		check(solutions)
		return 0
	else
		io.stderr:write("Found "..#solutions..", expected "..getExpectedNbOfModels().." models.\n")
		return check(solutions)
	end	
}

procedure check(solutions){
	for i,v in ipairs(solutions) do
		structure = v
		if(Vout~=nil and Vout~=V)then
			setvocabulary(v,V)
			structure = merge(S,v)
		end
		if(#modelexpand(T, structure, Vout)==0) then
			io.stderr:write("Found an invalid solution:\n")
			io.stderr:write(tostring(v))
			return 0
		end
	end
	return 1
}
procedure checkmodelsandnonmodels() {
	stdoptions.verbosity.solving=0
	stdoptions.verbosity.grounding=0
	stdoptions.timeout=5
	stdoptions.nbmodels=0
	structures = nbModelsTwoValuedExtensions(S)
	models = {}
	nonmodels = {}
	for i,structure in ipairs(structures) do
		if(#modelexpand(T, structure, Vout)==1) then
			table.insert(models,structure)
		else
			table.insert(nonmodels,structure)
		end
	end
	if(#models > getExpectedNbOfModels()) then
		io.stderr:write("At least one of these is not a model, but was not detected as such.\n")
		for i,structure in ipairs(models) do
			io.stderr:write(tostring(structure))
		end
		return 0
	elseif(#models < getExpectedNbOfModels()) then
		io.stderr:write("At least one of these is a model, but was not detected as such.\n")
		for i,structure in ipairs(nonmodels) do
			io.stderr:write(tostring(structure))
		end
		return 0
	end
	return 1
}
