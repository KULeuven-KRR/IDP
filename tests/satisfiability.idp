include <mx>

procedure satnobounds(){
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 10
	return run()
}

procedure satnoboundslong(){
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.timeout = 200
	return run()
}

// NOTE: only based on lazy tseitin delaying!!!!
procedure satlazy(){
	stdoptions.tseitindelay = true
	stdoptions.timeout = 10
	return run()
}

// NOTE: never enable delaying here which depends on well-founded definitions!
procedure satverylazy(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation=false
	stdoptions.satdelay=true
	stdoptions.tseitindelay=true
	stdoptions.timeout = 10
	return run()
}

procedure satwithbounds(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 10
	return run()
}

procedure satstable(){
	stdoptions.stablesemantics=true
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 10
	return run()
}

procedure satnonreduced(){
	stdoptions.reducedgrounding = false
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 10
	return run()
}

procedure satwithboundslong(){
	stdoptions.groundwithbounds = true
	stdoptions.liftedunitpropagation = true
	stdoptions.timeout = 200
	return run()
}

procedure satwithcp(){
	stdoptions.cpsupport = true
	stdoptions.cpgroundatoms = false
	stdoptions.timeout = 5
	return run()
}
procedure satwithfullcp(){
	stdoptions.cpsupport = true
	stdoptions.cpgroundatoms = true
	stdoptions.timeout = 10
	return run()
}


procedure satwithsymm(){
	stdoptions.timeout = 5
	stdoptions.groundwithbounds = false
	stdoptions.liftedunitpropagation = false
	stdoptions.symmetrybreaking = "static"
	return run()
}

procedure run() {
	stdoptions.verbosity.grounding=0
	stdoptions.verbosity.solving=0
	start = os.clock()
	stdoptions.nbmodels=1
	solution = modelexpand(T,S,Vout)
	io.stderr:write("Mx took "..os.clock()-start.." sec\n")
	
	if(solution==nil or #solution~=1) then
		if(getExpectedAModel()) then
			io.stderr:write("Found UNSAT, expected SAT.\n")
			return 0
		else
			io.stderr:write("Found UNSAT, expected UNSAT.\n")
			return 1
		end
	end

	structure = solution[1]
	if(Vout~=nil and Vout~=V) then
		setvocabulary(structure,V) // TODO merge should do setvoc?
		structure = merge(S,structure)
	end
	sols = modelexpand(T, structure, Vout)
	if(sols==nil or #sols==0) then
		io.stderr:write("Found an invalid partial model.\n")
		io.stderr:write(tostring(structure))
		return 0
	end
	io.stderr:write("Found SAT, expected SAT.\n")
	return 1
}
