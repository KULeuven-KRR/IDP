\documentclass[a4]{article}
\usepackage[english]{babel}
\usepackage{geometry}

\include{idp-latex}


\title{The \idp framework reference manual}
\author{KU Leuven Knowledge Representation and Reasoning research group}
\begin{document}
\maketitle
\setlength{\parindent}{0pt}
\newpage
\tableofcontents
\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installing And Running}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The system has been verified to run under Windows (7), OSX (Lion) and various unix versions.

\subsection{Building from source}
Required software packages:
\begin{itemize}
  \item C and C++ compiler, supporting most of the C++11 standard. Examples are GCC 4.4 or higher, clang 3.2 or visual studio 11.
  \item Cmake build environment. 
  \item Bison and flex packages or yacc and lex packages.
  \item Pdflatex and doxygen for building the documentation.
  \item (optional) Gecode for constraint programming support.
\end{itemize}

Assume idp is unpacked in $idpdir$, you want to build in $builddir$ (cannot be the same as $idpdir$) and install in $installdir$. Building and installing is then achieved by executing the following commands:
\begin{lstlisting}
cd <builddir>
cmake <idpdir> -DCMAKE_INSTALL_PREFIX=<installdir> -DCMAKE_BUILD_TYPE="Release"
make -j 4
make check
make install
\end{lstlisting}

Alternatively, cmake-gui can be used as a graphical way to set cmake options.

\subsection{Running the software}
One-shot execution of a procedure $proc$ with a set of files $files$ is achieved by running
\begin{lstlisting}
idp -e "proc()" files
\end{lstlisting}

An interactive interface using the files $files$ is started with 
\begin{lstlisting}
idp -i files
\end{lstlisting}

Afterwards, command help can be requested with the $help()$ command. Auto-completion is available via the tab key, ctrl-r will search the command history.

Currently including additional files during an interactive session is not supported.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Everything between \code{/*} and \code{*/} is a comment, as well as everything between \code{//} and the end of the line.  If a comment block starts with \code{/**}, but not with \code{/***}, then the comment is added as a description to the first thing after that comment block that can have a description.  Currently, only procedures can have a description.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Include statements}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Everywhere in an \idp file, a statement 
\begin{lstlisting}
	#include "path/to/file"
\end{lstlisting}
is replaced by the contents of the file \code{path/to/file}.
A statement
\begin{lstlisting}
	#include <filename>
\end{lstlisting}

is replaced by the contents of the standard library file \code{filename}.  Currently the following standard library files are available:
\begin{description}
\item[mx] Contains some useful model expansion procedures.
\end{description}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Namespaces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A namespace with name \code{MySpace} is declared by
\begin{lstlisting}
	namespace MySpace {
		// content of the namespace
	}
\end{lstlisting}

An object with name \code{MyName} declared in namespace \code{MySpace} can be referred to by \code{MySpace::MyName}.  Inside \code{MySpace}, \code{MyName} can simply be referred to by \code{MyName}.

A Namespace can contain namespaces, vocabularies, theories, structures, terms, queries, procedures, options and using statements.  A using statement is of one of the following forms
\begin{lstlisting}
	using namespace MySpace
	using vocabulary MyVoc
\end{lstlisting}
where \code{MySpace} is the name of a namespace, and \code{MyVoc} the name of a vocabulary.  Below such a using statement, objects \code{MyObj} declared in \code{MySpace}, respectively \code{MyVoc}, can be referred to by \code{MyObj}, instead of \code{MySpace::Myobj}, respectively \code{MyVoc::MyObj}.

Every object that is declared outside a namespace, is considered to be part of the global namespace.  The name of the global namespace is \code{global\_namespace}.  In other words, eery \idp file implicitely starts with \code{namespace global\_namespace \{} and ends wit han extra \code{\}}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vocabularies}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A vocabulary with name {\tt MyVoc} is declared by
\begin{lstlisting}
	vocabulary MyVoc {
		// contents of the vocabulary
	}
\end{lstlisting}
A vocabulary can contain symbol declarations, symbol pointers, and other vocabularies. Symbols are types (sorts), predicate and functions symbols.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symbol declarations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{ssec:symbols}
A type with name \code{MyType} is declared by
\begin{lstlisting}
	type MyType
\end{lstlisting}
When declaring a type, it can be stated that this type is a subtype or supertype of a set of other types.  The following declares \code{MyType} to be a supbtype of the previously declared types \code{A1} and \code{A2}, and a supertype of the previously declared types \code{B1} and {B2}:
\begin{lstlisting}
	type MyType isa A1, A2 contains B1, B2
\end{lstlisting}
A predicate with name \code{MyPred}, arity 3 and types \code{T1},\code{T2},\code{T3} is declared by
\begin{lstlisting}
	MyPred(T1,T2,T3)
\end{lstlisting}

A predicate with arity zero can be declared by \code{MyPred()} or \code{MyPred}.

A function with name \code{MyFunc}, input types \code{T1},\code{T2},\code{T3} and output type \code{T}  is declared by
\begin{lstlisting}
	MyFunc(T1,T2,T3):T
\end{lstlisting}

A partial function is declared by 
\begin{lstlisting}
	partial MyFunc(T1,T2,T3):T
\end{lstlisting}

Constants of type \code{T} can be declared by \code{MyConst:T} or \code{MyConst():T}.  Besides functinos with an identifier as name, functions of arity two with names \code{+,-,*,/,\%}  and \code{\textasciicircum} can be declared, as well as unary functions iwth names \code{-} and \code{abs}.

Any symbol has to be declared on its own line.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symbol pointers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

To include a type, predicate, or function from a previously declared vocabulary \code{V} in another vocabulary \code{W}, write
\begin{lstlisting}
	/* Declaration of vocabulary V*/
	vocabulary V {
		//...
		type A
		P(A)
		F(A,A):A
		//...
	}

	vocabulary W {
		extern type V::A
		extern V::P[A]	//also possible: extern V::P/1
		extern V::F[A,A:A]	also possible: extern V::F/2:1
	}
\end{lstlisting}

In the example, explicitly including type \code{A} of vocabulary \code{V} in \code{W} is not needed, since types of included predicates or functions are automatically included themselves.  To include the whole vocabulary \code{V} in \code{W} at once, used
\begin{lstlisting}
	vocabulary W {
		extern vocabulary V
	}
\end{lstlisting}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The standard vocabulary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The global namespace contains a fixed vocabulary \code{std}, which is defined as follows:

\begin{lstlisting}
	vocabulary std {
		type nat	
		type int contains nat
		type float contains int
		type char
		type string contains char

		+(int,int) : int
		-(int,int) : int
		*(int,int) : int
		/(int,int) : int
		%(int,int) : int
		abs(int) : int
		-(int) : int
		
		+(float,float) : float
		-(float,float) : float
		*(float,float) : float
		/(float,float) : float
		^(float,float) : float
		abs(float) : float
		-(float) : float
	}
\end{lstlisting}
Every vocabulary implicitly contains all symbols of \code{std}.  Also, every vocabulary contains for each of its types \code{A} the predicates \code{=(A,A)}, \code{<(A,A)}, and \code{>(A,A)} and the functions \code{MIN:A}, \code{MAX:A}, \code{SUCC(A):A} and \code{PRED(A):A}. In every structure, the symbols of \code{std} have the following interpretation:

\begin{center}
	
\begin{tabular}{l|l}
\code{nat} & all natural numbers \\
\code{int} & all integer numbers \\ 
\code{float} & all floating point numbers \\
\code{char} & all characters \\
\code{string} & all strings \\
\code{+(int,int) : int} & integer addition \\
\code{-(int,int) : int } &integer subtraction \\
\code{*(int,int) : int} & integer multiplication \\
\code{/(int,int) : int} & integer division \\
\code{\%(int,int) : int} & remainder \\
\code{abs(int) : int} & absolute value \\
\code{-(int) : int} & unary minus \\
\code{+(float,float) : float} & floating point addition \\
\code{-(float,float) : float} & floating point subtraction \\
\code{*(float,float) : float} & floating point multiplication \\
\code{/(float,float) : float} & floating point division \\ 
\code{\textasciicircum(float,float) : float} & floating point exponentiation \\
\code{abs(float) : float} & absolute value \\
\code{-(float) : float} & unary minus
\end{tabular} 

\end{center}

The predicate \code{=/2} is always interpreted by equality.  The order $<_{dom}$ on domain elements is defined by
\begin{itemize}
	\item numers are smaller than non-numers;
\item strings are smaller than compound domain elements (see bolow for a definitions of a compound domain element);
\item $d_1<_{dom} d_2$ if $d_1$ and $d_2$ are numbers and $d_1<d_2$;
\item $d_1<_{dom} d_2$ if $d_1$ and $d_2$ are strings that are nut numbers and $d_1$ is before $d_2$ in the lexicographic ordering;
\item $d_1<_{dom} d_2$ is some total order on compound domain elements (which we do not specify).
\end{itemize}

Every structure contains the following fixed interpretations:

\begin{center}
	
\begin{tabular}{l|l}
\code{<(A,A)} & the projection of $<_{dom}$ to the domain of A \\
\code{>(A,A)} & the projection of $>_{dom}$ to the domain of A \\
\code{MIN:A} & the $<_{dom}$-least element in the domain of A \\
\code{MAX:A} & the $<_{dom}$-greatest element in the domain of A \\
\code{SUCC(A):A} & the partial function that maps an element a  of the domain of \code{A} \\ & to the $<_{dom}$-least element of the domain of A that is strictly larger than a \\
\code{PRED(A):A} & the partial function that maps an element a  of the domain of \code{A} \\ & to the $<_{dom}$-greatest element of the domain of A that is strictly smaller than a \\
\end{tabular} 

\end{center}

In an IDP-file, you should disambiguate which \code{MAX} you want to use.  This is done by \code{MAX[:MyType]}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Theories}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A theory with name \code{MyTheory} over a vocabulary \code{MyVoc} is declared by
\begin{lstlisting}
	theory MyTheory : MyVoc {
		// contents of the theory
	}
\end{lstlisting}
A theory contains sentences and inductive definitions.

\subsection{Sentences}


\subsubsection{Terms}

Before explaining the syntax for sentences, we need to introduce the concept of a term and a formula. We also give the syntax for terms and formulas in \idp.\\


A \emph{term} is inductively defined as follows:
\begin{itemize}
	\item a variable is a term;
	\item a constant is a term;
	\item if $F$ is a function symbol with $n$ input arguments and $t_1, \ldots, t_n$ are terms, then $F(t_1,\ldots,t_n)$ is a term. 
\end{itemize}
In \idp, variables start with a letter and may contain letters, digits and underscores. When writing a term in \idp, the constant and function symbols occurring in that term should be declared before. \\
The \emph{type of a term} is defined as its return type (see section~\ref{ssec:symbols}) in the case of constants and functions. The type of a variable is derived from its occurrences in formulas (see section~\ref{ssec:vtype}). If a term occurs in an input position of a function, then the type of the term and the type of the input position must have a common ancestor type. 

\subsubsection{Formulas and Sentences}

A \emph{formula} is inductively defined by:
\begin{itemize}
	\item \textbf{true} and \textbf{false} are formulas;
	\item if $P$ is a predicate symbol with arity $n$ and $t_1,\ldots,t_n$ are terms, then $P(t_1,\ldots,t_n)$ is a formula;
	\item if $t_1$ and $t_2$ are terms, then $t_1 = t_2$ is a formula;
	\item if $\varphi$ and $\psi$ are formulas and $x$ is a variable, then the following are formulas: $\lnot \varphi$, $\varphi \land \psi$, $\varphi \lor \psi$, $\varphi \limplies \psi$, $\varphi \limpliedby \psi$, $\varphi \equiv \psi$, $\forall x\ \varphi$, and $\exists x\ \varphi$.
\end{itemize}
The following order of binding is used: $\lnot$ binds tightest, next $\land$ and $\lor$, then $\limplies$ and $\equiv$, and finally $\forall$ and $\exists$. Desambiguation can be done using brackets `(' and `)'. E.g. the formula $\forall x\ P(x) \land \lnot Q(x) \limplies R(x)$ is equivalent to the formula $\forall x\ ((P(x) \land (\lnot Q(x))) \limplies R(x))$.

As for terms, if term $t$ occurs in predicate $P$, then the type of $t$ and the type of the input position of $P$ where it occurs must have a common ancestor type. For formulas of the form $t_1 = t_2$, $t_1$ and $t_2$ must have a common ancestor type.


The \emph{scope} of a quantification $\forall x$ or $\exists x$, is the quantified formula. E.g., in $\forall x\ \psi$, the scope of $\forall x$ is the formula $\psi$. An occurrence of a variable $x$ that is not inside the scope of a quantification $\forall x$ or $\exists x$ is called \emph{free}. A \emph{sentence} is a formula containing no free occurrences of variables. If an \idp problem specification contains formulas that are not sentences, the system will implicitly quantify this variable universally and return a warning message, specifying which variables occur free. Each sentence in \idp should end with a dot `.'.

The \idp syntax of the different symbols in formulas are given in the table below. Also the informal meaning of the symbols is given.
\begin{center}
\begin{tabular}{c|c|l}
Logic & \idp & Declarative reading \\
\hline
$\land$		& {\tt \&}	& and \\
$\lor$		& {\tt |}	& or	\\
$\lnot$		& \verb1~1	& not \\
$\limplies$		& {\tt =>}	& implies \\
$\limpliedby$		& {\tt <=}	& is implied by \\
$\equiv$		& {\tt <=>}	& is equivalent to \\
$\forall$	& {\tt !}	& for each \\
$\exists$	& {\tt ?}	& there exists \\
$=$			& {\tt =}	& equals \\
$\neq$		& \verb1~=1	& does not equal \\ 
\end{tabular}
\end{center}

Besides this, for every natural number $n$, \idp also supports the following quantifiers (with their respective meanings):

\begin{center}
\begin{tabular}{c|c|l}
\idp & Declarative reading \\
\hline
\code{?n}	& there exist $n$ different elements such that \\
\code{?<n} & there exist less than $n$ \\
\code{?=<n} & there exist at most $n$\\
\code{?=n} & there exist exactly $n$\\
\code{?>n} & there exist more than $n$
\end{tabular}
\end{center}

A universally quantified formula $\forall x\ P(x)$ becomes `{\tt !\,x\,:\,P(x)}' in \idp syntax, and similarly for existentially quantified formulas. As a shorthand for the formula `{\tt !\,x\,:\,!\,y\,:\,!\,z\,:\,Q(x,y,z).}', one can write `{\tt !\,x y z\,:\,Q(x,y,z)}'. 



In \idp, every variable has a type. The informal meaning of a sentence of the form $\forall x\ \psi$, respectively $\exists x\ \psi$, where $x$ has type $T$ is then `for each object $x$ of type $T$, $\psi$ must be true', respectively `there exists at least one object $x$ of type $T$ such that $\psi$ is true'. The type of a variable can be declared by the user, or derived by \idp (see section~\ref{ssec:vtype}).


\subsubsection{Definitions}
A definition defines a concept, i.e. a predicate, in terms of other predicates. Formally, a definition is a set of rules of the form 
\[ \forall x_1,\ldots,x_n\ P(t_1,\ldots,t_m) \lrule \varphi \]
where $P$ is a predicate symbol, $t_1,\ldots,t_m$ are terms that may contain the variables $x_1,\ldots,x_n$ and $\varphi$ a formula that may contain these variables. $P(t_1,\ldots,t_m)$ is called the \emph{head} of the rule and $\psi$ the \emph{body}. 

A definition in \idp syntax consists of a set of rules, enclosed by `{\tt \{}' and `{\tt \}}'. Each rule ends with a `{\tt .}'. The definitional implication $\lrule$ is written `{\tt <-}'. The quantifications before the head may be omitted in \idp, i.e., all free variables of a rule are implicitly universally quantified. If the body of a rule is empty, the rule symbol `{\tt <-}' can be omitted. Recursive definitions are allowed in \idp. The semantics for a definitions are the wellfounded semantics \todo{reference}.





\subsection{Chains of (in)equalities}
As in mathematics, one can write chains of (in)equalities in \idp. They can be used as shorthands for conjunctions of (in)equalities. E.g.:
\begin{lstlisting}
	! x y : (1 =< x < y =< 5) => ...
	// is a shorthand for
	! x y : (1 =< x) & (x < y) & (y =< 5) => ...
\end{lstlisting}

\subsection{Aggregates}
Aggregates are functions that take a set as argument, instead of a simple variable. \idp supports some aggregates that map a set to an integer. As such, they can be seen as integer terms.

There are two kinds of sets in \idp. 
\begin{itemize}
	\item An expression of the form `{\tt [ (phi\_1,t\_1) ; (phi\_2,t\_2) ; ... ; (phi\_n,t\_n) ]}', where each {\tt phi\_i} is a formula and each \code{t\_i} is a term.  %This set denotes the set of all the {\tt t\_i} for which {\tt phi\_i} that are true.
	\item An expression of the form `{\tt \{ x\_1 x\_2 ... x\_n : phi:t \}}', where the {\tt x\_i} are variables, {\tt phi} is a formula and $t$ is a term.  %This denotes the set of all tuples  {\tt (a\_1,a\_2, ...,a\_n)} of objects such that {\tt phi} is true if each occurrence of an {\tt x\_i} in {\tt phi} is replaced by {\tt a\_i}. 
\end{itemize} 
The current system has support for five aggregate functions:
\begin{description}
	\item[Cardinality:] The cardinality of a set is the number of elements in that set. The \idp syntax for the cardinality of a set $S$ is `{\tt card} $S$' or `{\tt \#} $S$'. For the first kind of sets, this denotes the number of formulas {\tt phi\_i} that are true.  For the second kind, this is interpreted as the number of tuples {\tt(a\_1,a\_2,..., a\_n)} such that {\tt phi} is true.
	\item[Sum:] Let $S$ be a set of the second form, i.e., of the form `{\tt \{ x\_1 x\_2 ... x\_n : phi: t \}}'. Then the interpretation of `{\tt sum} $S$' denotes the number
	\[ \sum_{{\tt(a\_1,a\_2,..., a\_n)} | I\vDash {\tt phi}} {\tt t }, \]
	i.e., it is the sum of all the terms for which there exist {\tt a\_1,\ldots, a\_n} that make the formula {\tt phi} true. For sets of the first sort, this is interpreted as 
\[ \sum_{i | I\vDash {\tt phi\_i}} {\tt t_i }. \]
	\item[Product:] Products are defined similar to sum.  
	\item[Maximum:] One can write `{\tt max} $S$' to denote the maximum value of the term in $S$, i.e.,
	\[ \max_{{\tt(a\_1,a\_2,..., a\_n)} | I\vDash {\tt phi}} {\tt t} \] for sets of the second sort.  Sets of the first sort are handled analogously. %{\tt(a\_1,a\_2,..., a\_n)} \in S} {\tt a\_1 }, \]
	\item[Minimum:] To get the minimum value, write `{\tt min} $S$'.
\end{description}
When using cardinality, the terms do not matter.  You can choose to write $1$ for every term, but are also allowed to leave out the terms.
%{\color{Red}IMPORTANT NOTE}: At the moment, the solver cannot handle negative numbers in product aggregates.

\subsection{Partial functions}\label{ssec:partial}
A normal function is total: it assigns an output value to each of its input values. On the other hand, \emph{partial} functions do not necessarily have this property. In \idp, partial function $F$ can arise in different situations. Either $F$ is explicitely declared as partial function, or it is declared total, but its input types or output type are subtypes or integer types.

The semantics of a partial function $F$ is given by transforming constraints and rules where $F$ occurs as follows:
\begin{itemize}
	\item in a \emph{positive} context, $P(\ldots,F(x),\ldots)$ is transformed to $\forall y\ (F(x) = y \limplies P(\ldots,y,\ldots)$;
	\item in a negative context, $P(\ldots,F(x),\ldots)$ is transformed to $\exists y\ (F(y) = y \land P(\ldots,y,\ldots)$.
\end{itemize}
Here, $P(\ldots,F(x),\ldots)$ occurs in a positive context if it occurs in sentence and in the scope of an even number of negations, or it occurs in a body of a rule and in the scope of an odd number of negations. All other occurrences are in a negative context. 

                                                              
\subsection{The Type of a Variable}\label{ssec:vtype}
There are two ways to assign a type $t$ to a variable $v$:
\begin{itemize}
	\item Explicitely mention the type of $v$ between `{\tt [}' and `{\tt ]}' when $v$ is quantified. Then $v$ gets type $t$ in the scope of the quantifier. E.g.,
	\begin{lstlisting}
	theory T: V {
		! MyVar[MyType] : ? MyVar2[MyType2] MyVar3[MyType3] : //...
	}
	\end{lstlisting}
	\item Do not mention the type of $v$ but let the system automatically derive it. The rest of this section explains how this is done.
\end{itemize}

\subsubsection{Automatic derivation of types for variables}



We distinguish between \emph{typed} and \emph{untyped} occurrences. The following are typed occurrences of a variable $x$:
\begin{itemize}
	\item an occurrence as argument of a non-overloaded predicate: $P(\ldots,x,\ldots)$;
	\item an occurrence as argument of a non-overloaded function: $F(\ldots,x,\ldots) = \ldots$;
	\item an occurrence as return value of a non-overloaded function: $F(\ldots) = x$ or $F(\ldots) \neq x$. 
\end{itemize}

All others positions are untyped. 

An overloaded predicate or function symbol can be disambiguated by scecifying its vocabluary and / or types.  E.g.,
\begin{lstlisting}
	! x: MyVoc::P[A,A](x,x).
	! y: ?1 x : F[A:A](x) = y.
	MyVoc::C[:A] > 2.
\end{lstlisting}
In this case, te occurences of all variables are typed.


Basically, if a variable occurs in a typed position, it gets the type of that position.  
If a declared variable with type {\tt T\_1} occurs in a typed position of type {\tt T\_2}, then {\tt T\_1} and {\tt T\_2} should have a common ancestor type.


The more complicated cases arise when a variable does not occur in any typed position, or it occurs in two typed positions with a different type. The system is designed to give a reasonable type to such variables. However, the choices made by the system are ad hoc and are probably not the ones the user intended. %When in doubt, one can explicitely assign types to variables, or run \gidl with option {\tt --data} to check the derived types.
\todo{stukje over wat typederivation precies doet voor gelijkheid en zo.. Broes?}

First consider the case where a variable occurs in typed positions with different types. The \idp system will then give a warning. If all the typed positions where the variable occurs have a common ancestor type $T$, then the variable is assigned this type $T$. If they do not have a common ancestor, no derivation is done.

Now consider the case where a variable does not occur in a typed position. Then, the \idp system tries to find out what the type of the variable should be using its occurences in untyped position in built-in overloaded functions.  For example, when a variable $x$ only occurs in $x=t$, then $x$ will get the same type as $t$.  This behaviour might not always be the desired, so the \idp system will give a warning, including which type it derived for the variable.  It's always safer to declare a type for the variable in this case.  If it is not possible to derive a type for $x$ in this way either, the \idp system reports an error.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terms}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Besides from appearing in theories, terms can also be defined separately, for example for use in a minimize inference. The syntax for declaring a term \code{MyTerm} over a vocabulary \code{MyVoc} is
\begin{lstlisting}
	term MyStruct: MyVoc {
		//contents of the term
	}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Queries}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A query with name \code{MyQuery} over a vocabulary \code{MyVoc} is declared by
\begin{lstlisting}
	query MyQuery: MyVoc {
		//contents of the query
	}
\end{lstlisting}
Here ``contents of the query'' is of the following form 
\begin{lstlisting}
		{ MyVar1 MyVar2 ... MyVarn : MyFormula}
\end{lstlisting}
where \code{MyVar1}, \code{MyVar2},\ldots,\code{MyVarn} are the free variables of the \fodot formula \code{MyFormula}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A (three-valued) structure with name \code{MyStruct} over a vocabulary \code{MyVoc} is declared by
\begin{lstlisting}
	structure MyStruct: MyVoc {
		//contents of the structures
	}
\end{lstlisting}
or by 
\begin{lstlisting}
	aspstructure MyStruct: MyVoc {
		//contents of the structures
	}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Contents of a structure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


A particular input to a problem can be given by giving a (three valued) interpretation to all types and some predicate and function symbols of a given vocabulary. Here, we describe the different ways to specify a structure.

\subsubsection{Type Enumeration}
The syntax for a type enumeration is 
\begin{lstlisting}
	MyType = { El_1; El_2; ... ; El_n }
\end{lstlisting}
where {\tt MyType} is the name of the enumerated type and {\tt El\_1; El\_2; ... ; El\_n } are the names of the objects of that type. Names of objects can be (positive and negative) integers, strings, chars, compound domain elements, or identifiers that start with an upper- or lowercase letter. 
Identifiers are shorthands for strings (without the quotes) and can be interchanged.
\todo{Important: in the lua code, the identifiers cannot be used safely, only their string equivalent}
If one type is a subtype of another, all elements of the subtype are added to the supertype also.  In the case all subtypes of a given type are specified, the supertype is derived to be the union of all elements of the subtypes.  If a type is not specified, all domain elements of that type that occur in a predicate or function interpretation (see below) are automatically added to that type.  


\subsubsection{Predicate Enumeration}
The syntax for enumerating all tuples for which a predicate {\tt MyPred} with $n$ arguments is true is as follows.
\begin{lstlisting}
	MyPred = { El_1_1,..., El_1_n; 
				  ... ; 
				  El_m_1,..., El_m_n 
				}
\end{lstlisting}

It is also possible to write parentheses around tuples.
\begin{lstlisting}
	MyPred = { (El_1_1,..., El_1_n); 
				  ... ; 
				  (El_m_1,..., El_m_n) 
				}
\end{lstlisting}
This notation makes it possible to state that a proposition (a predicate with no arguments) is true, by using an empty tuple.
\begin{lstlisting}
	true = { () }
	false = { }
\end{lstlisting}
However, it might be easier to use \code{true} and \code{false} instead of \code{\{ () \}} and \code{\{\}}.

\subsubsection{Function Enumeration}
The syntax for enumerating a function {\tt MyFunc} with $n$ arguments is 
\begin{lstlisting}
	MyFunc = { El_1_1,...,El_1_n -> El_1;
		...;
		El_m_1,...,El_m_n -> El_m
	}
\end{lstlisting}
To give the interpretation of a constant, one can simply write `{\tt MyConst = El}' instead of `{\tt MyConst = \{ -> El \}}'.

\subsubsection{Compound Domain Elements}
A function applied to a tuple of domain elements can be used as a domain element.  We call such a domain element a \textit{compound domain element}.  An example is the domain element \code{F(1,a)}. If \code{F/n} is a function then 
\begin{lstlisting}
	F = generate
\end{lstlisting}
specifies that the interpretation of \code{F} is the two-valued interpretation that maps each tuple \code{(d\_1,\ldots,d\_n)} to the compound domain element \code{F(d\_1,\ldots,d\_n)}.

\subsubsection{Three-Valued Predicate/Function interpretations}
Three-valued interpretations are given by either
\begin{itemize}
	\item enumerating the certainly true and certainly false tuples;
	\item enumerating the certainly true and the unknown tuples;
	\item enumerating the unknown and the certainly false tuples.
\end{itemize}
To sepcify which tuples are enumerated, use \code{<ct>}, \code{<cf>} and \code{<u>}.  For example
\begin{lstlisting}
	P<ct> = { /* enumeration of the certainly true tuples of P */ }
	P<u> = { /* enumeration of the unknown tuples of P */ }
\end{lstlisting}

\subsubsection{Interpretation by Procedures}
The syntax 
\begin{lstlisting}
	P = procedure MyProc
\end{lstlisting}
is used to interpret a predicate or function symbol \code{P} by a procedure \code{MyProc} (see below).  If \code{P} is an $n$-ary predicate, then \code{MyProc} should be an $n$-ary procedure that returns a boolean.  If \code{P} is an $n$-ary function, then \code{MyProc} should be and $n$-ary function that returns a number, string, or compound domain element.


\subsubsection{Shorthands}
Shorthands like `{\tt MyType = \{1..10; 15..20\}}' or `{\tt MyType = \{ a..e; A..E \}}' may be used for enumerating types or predicates with only one argument.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ASP structures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
An ASP structure consists of a list of facts in the usual ASP syntax.  In particular, everything from a \code{\%} till the end of the line is considered a comment, and \code{-} before an atom denotes classical negation (negation as failure is not available).  A fact about functions is written like \code{F(a)=b} or \code{-F(c)=d}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Procedures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Declaring a procedure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A procedure with name {\tt MyProc} and arguments {\tt A1}, \ldots, {\tt An} is declared by 
\begin{lstlisting}
	procedure MyProc(A1,...,An) {
		// contents of the procedure
	}
\end{lstlisting}
Inside a procedure, any chunk of Lua code can be written. For Lua's reference manual, see \url{http://www.lua.org/manual/5.1/}. In the following, we assume that the reader is familiar with the basic concepts of Lua.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\idp types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Besides the standard types of variables available in Lua, the following extra types are available in \idp procedures.
\begin{description}
	\item[sort] A set of sorts with the same name. Can be used as a single sort if the set is a singleton.
	\item[predicate\_symbol] A set of predicates with the same name, but possibly with different arities. Can be used as a single predicate if the set is a singleton. If {\tt P} is a predicate\_symbol and {\tt n} an integer, then {\tt P/n} returns a predicate\_symbol containing all predicates in {\tt P} with arity {\tt n}. If {\tt s1}, \ldots, {\tt sn} are sorts, then {\tt P[s1,...,sn]} returns a predicate\_symbol containing all predicates $Q/n$ in {\tt P}, such that the $i$'th sort of $Q$ belongs to the set {\tt si}, for $1 \leq i \leq n$.
	\item[function\_symbol] A set of first-order functions with the same name, but possibly with different arities. Can be used as a single first-order function if the set is a singleton. If {\tt F} is a function\_symbol and {\tt n} an integer, then {\tt F/n:1} returns a function\_symbol containing all function in {\tt F} with arity {\tt n}. If {\tt s1}, \ldots, {\tt sn}, {\tt t} are sorts, then {\tt F[s1,...,sn:t]} returns a function\_symbol containing all functions $G/n$ in {\tt F}, such that the $i$'th sort of $F$ belongs to the set {\tt si}, for $1 \leq i \leq n$, and the output sort of $G$ belongs to {\tt t}.
	\item[symbol] A set of symbols of a vocabulary with the same name. Can be used as if it were a sort, predicate\_symbol, or function\_symbol.
	\item[vocabulary] A vocabulary. If {\tt V} is a vocabulary and {\tt s} a string, {\tt V[s]} returns the symbols in {\tt V} with name {\tt s}. 
	\item[compound] A domainelement of the form $F(d_1,\ldots,d_n)$, where $F$ is a first-order function and $d_1$, \ldots, $d_n$ are domain elements.
	\item[tuple] A tuple of domain elements. {\tt T[n]} returns the {\tt n}'th element in tuple {\tt T}.
	\item[predicate\_table] A table of tuples of domain elements.
	\item[predicate\_interpretation] An interpretation for a predicate. If {\tt T} is a predicate\_interpreation, then {\tt T.ct}, {\tt T.pt}, {\tt T.cf}, {\tt T.pf} return a predicate\_table containing, respectively, the certainly true, possibly true, certainly false, and possibly false tuples in {\tt T}. % HIER ONTBREEKT __newindex
	\item[function\_interpretation] An interpretation for a function. {\tt F.graph} returns the predicate\_interpretation of the graph associated to the function\_interpreation {\tt F}. % HIER ONTBREEKT __newindex en __call
	\item[structure] A first-order structure. To obtain the interpretation of a sort, singleton predicate\_symbol, or singleton function\_symbol {\tt symb} in structure {\tt S}, write {\tt S[symb]}.
	\item[theory] A logic theory.
	\item[options] A set of options.
	\item[namespace] A namespace.
	\item[overloaded] An overloaded object.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Built-in procedures}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A lot of procedures (modelexpansion, querying, propagation, calculating known definitions,\ldots) are allready built-in.  
%TODO: betere verdeling van alle inferences over de verschillende subsubsections...
\subsubsection{Manipulation of elements}
\begin{description}
	\item[createdummytuple()]
		Create an empty tuple.
\end{description}


\subsubsection{Manipulation of interpretations}
\begin{description}
	\item[clean(structure)]
		Modifies the given structure (the structure is the same, but its representation changes): transforms fully specified three-valued relations into two-valued ones.  For example if \code{P} has domain \code[1..2] and in the given structure, \code{P<ct> = \{1\}, P<cf> = \{2\}}, in the end, \code{P} is \code{\{1\}}.
	\item[clone(structure)]
		Returns a structure identical to the given one.
	\item[isconsistent(structure)]
 		Check whether the structure is consistent.
	\item[makefalse(predicate\_interpretation,table)]
 		Sets all tuples of the given table to false
 		Modifies the table-interpretation.
	\item[ makefalse(predicate\_interpretation,tuple)]
 		Sets the interpretaion of the given tuple to false
 		Modifies the table-interpretation.
	\item[ maketrue(predicate\_interpretation,table)]
 		Sets all tuples of the given table to true
 		Modifies the table-interpretation.
	\item[ maketrue(predicate\_interpretation,tuple)]
 		Sets the interpretation of the given tuple to true
 		Modifies the table-interpretation.
	\item[ makeunknown(predicate\_interpretation,table)]
 		Sets all tuples of the given table to unknown
 		Modifies the table-interpretation.
	\item[ makeunknown(predicate\_interpretation,tuple)]
 		Sets the interpretation of the given tuple to unknown
 		Modifies the table-interpretation.
	\item[newstructure(vocabulary,string)]
 		Create an empty structure with the given name over the given vocabulary.
\end{description}

\subsubsection{Manipulation of theories}
\begin{description}
	\item[clone(theory)]
		Retrurns a theory identical to the given one.
	\item[completion(theory)]
		Add definitional completion of all the definitions in the theory to the given theory. Modifies its argument.
	\item[flatten(theory)]
		Rewrites formulas with the same operations in their child formulas by reducing the nesting. For example $a \wedge (b\wedge c)$ will be rewritten to $a\wedge b \wedge c$.
		Modifies the given theory. 
	\item[merge(theory,theory)]
 		Create a new theory which is the result of combining (the conjunction of) both input theories.
	\item[pushnegations(theory)]
 		Push negations inwards until they are right in front of literals.
 		Modifies the given theory.
	\item[removenesting(theory)]
 		Move nested terms out of predicates (except for the equality-predicate) and functions.
 		Modifies the given theory.
\end{description}

\subsubsection{Options}
\begin{description}
	\item[getoptions()]
 		Get the current options.
	\item[newoptions()]
 		Create new options, equal to the standard options.
	\item[setascurrentoptions(options)]
 		Sets the given options as the current options, used by all other commands.
\end{description}

\subsubsection{Miscellaneous}
\begin{description}
	\item[help(namespace)]
 		List the procedures in the given namespace.
	\item[idptype(something)]
 		Returns custom typeids for first-class idp citizens.
	\item[parse(string)]
 		Parses the given file and adds its information into the datastructures.
	\item[range(number,number)]
 		Create a domain containing all integers between First and Last.
\end{description}


\subsubsection{Tables and iterators}
\begin{description}
	\item[elements(d)]
		Returns a procedure, iterator, and 0 such that
			``for e in elements(d) do ... end'' 
		iterates over all elements in the given domain d.
	\item[iterator(domain)]
 		Create an iterator for the given sorttable.
	\item[iterator(predicate\_table)]
 		Create an iterator for the given predtable.
	\item[size(predicate\_table)]
 		Get the size of the given table.
	\item[tuples(table)]
 		Returns a procedure, iterator, and a tuple such that
 		``for t in tuples(table) do ... end''
 		iterates over all tuples in the given predicate table.
\end{description}


\subsubsection{Extending structures}
\begin{description}
	\item[alltwovaluedextensions(structure)] This procedures takes one (three-valued) structure and returns all structures over the same vocabulary that extend the given structure and are two-valued.
	\item[alltwovaluedextensions(table)]
		This procedures takes a table of structures and returns all two-valued extensions of any of the given structures.
	\item[calculatedefinitions(theory,structure)]
		Make the structure more precise than the given one by evaluating all definitions with known open symbols. This procedure works recursively: as long as some definition of which all open symbols are known exists, it calculates the definition (possibly deriving open symbols of other definitions).
	\item[minimize(theory,structure,term)] Returns all models of the theory that extend the given structure and such that the term is minimal.
	\item[modelexpandpartial(theory,structure)]
		Apply model expansion to theory T, structure S.
 		The result is a table of (possibly three-valued) structures that are more precise then S and that satisfy T  and, if getoptions().trace == true, a trace of the solver.
		(this procedure is equivalent to first calling modelexpandpartial and subsequently calling alltwovaluedextensions. 
	\item[modelexpand(theory,structure)]
 		Apply model expansion to theory T, structure S.
 		The result is a table of two-valued structures that are more precise then S and that satisfy T and, if getoptions().trace == true, a trace of the solver.
		(this procedure is equivalent to first calling modelexpandpartial and subsequently calling alltwovaluedextensions. 
	%%%%%%%%%PROPAGATION%%%%%%%%%%
	\item[groundpropagate(theory,structure)]
 		Return a structure, made more precise than the input by grounding and unit propagation on the theory.
		Returns nil when propagation makes the givens structure inconsistent.
	\item[optimalpropagate(theory,structure)]
 		Return a structure, made more precise than the input by generating all models and checking which literals always have the same truth value
 		This propagation is complete: everything that can be derived from the theory will be derived. 
 		Returns nil when propagation results in an inconsistent structure.
	\item[propagate(theory,structure)]
 		Returns a structure, made more precise than the input by doing symbolic propagation on the theory.
 		Returns nil when propagation results in an inconsistent structure.
\end{description}


\subsubsection{Grounding}
\begin{description}
	\item[ground(theory,structure)]
 		Create the reduced grounding of the given theory and structure. 
	\item[printgrounding(theory,structure)]
 		Print the reduced grounding of the given theory and structure.
 		MEMORY EFFICIENT: does not store the grounding internally.
\end{description}

\subsubsection{Other high-level inferences}
\begin{description}
	\item[query(query,structure)]
 		Generate all solutions to the given query in the given structure. The result is the set of element-tuples that certainly satisfy the query in the structure.
	\item[sat(theory,structure)]
		Checks satisfiability of the given theory-structure combination. Returns true if and only if there exists a model extending the structure and satisfying the theory.
\end{description}

\subsubsection{The mx library}
The mx standard library file contains some useful commands for model expansion. It can be used by 
\begin{lstlisting}
	#include <mx>
\end{lstlisting}
All commands in the mx standard library file are defined in a namespace with the same name (and hence should be called by \code{mx::command(...)}.
The following commands are supported by mx:
\begin{description}
	\item[one(theory,structure)]
		Does model expansion but only searches for one model (no matter what the \code{nbmodels} option is set to). Returns this structure (in contrary to the standard modelexpansion which returns a list of structures).
	\item[all(theory,structure)] 
		Returns all models of the theory that extend the given structure.
	\item[printmodels(list)]
		Prints a given list of models or prints unsatisfiable if the list is empty.
\end{description}

\subsubsection{The table\_utils library}
The table\_utils standard library file can be include by 
\begin{lstlisting}
	#include <table_utils>
\end{lstlisting}
It contains several useful commands for manipulating tables, converting predicate tables to lua-tables,\ldots.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Options}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \idp system has various options.  To set an option, you can use the following lua-code
\begin{lstlisting}
	stdoptions.MyOption = MyValue
\end{lstlisting}
where \code{MyOption} is the name of the option and \code{MyValue} is the value you want to give it. If you want to have multiple option sets, you can make them with them with
\begin{lstlisting}
	FirstOptionSet = newOptions()
	SecondOptionSet = newOptions()
	FirstOptionSet.MyOption = MyValue
	SecondOptionSet.MyOption = MyValue
\end{lstlisting}
To activate an option set, use the procedure \code{setascurrentoptions(MyOptionSet)}.  From that moment, \code{MyOptionSet} will be used in all comands.

\subsection{Verbosity options}
\begin{description}
	\item[{groundverbosity = [0..max(int)]}] Verbosity of the grounder.  The higher the verbosity, the more debug information is printed.
	\item[{satverbosity = [0..max(int)]}] Like groundverbosity, but controls the verbosity of \minisatid
	\item[{propagateverbosity = [0..max(int)]}] Like groundverbosity, but controls the verbosity of the propagation.
\end{description}

\subsection{Modelexpansion options}
\begin{description}
	\item[{nbmodels = [0..max(int)]}] Set the number of models wanted from the modelexpansion inference.  If set to 0, all models are returned.
	\item[{trace = [false, true]}] If true, the procedure modelexpand produces also an execution trace of \minisatid 
\end{description}

\subsection{Propagation options}
\begin{description}
	\item[{groundwithbounds = [false, true]}] Enable/disable bounded grounding (if enabled, first do symbolic propagation to provide ct and cf bounds for formulas to reduce the size of the grounding).
	\item[{longestbranch = [0..2147483647]}] The longest branch allowed in BDDs during propagation. The higher, the more precise the propagation will be (but also, the more time it will take).
	\item[{nrpropsteps = [0..2147483647]}] The number of propagation steps used in the propagate-inference. The higher, the more precise the propagation will be (but also, the more time it will take).
	\item[{relativepropsteps =  [false, true]}] If true, the total number of propagation steps is nrpropsteps multiplied by the number of formulas.

\end{description}

\subsection{Printing options}
\begin{description}
	\item[{language = [ecnf, idp, %latex, asp, txt
				tptp]}] The language used when printing objects. 
	\item[{longnames = [false, true]}] If true, everything is printed with reference to their vocabulary.  For example, a predicate \code{P} from vocabulary \code{V} will be printed as \code{V::P} instead of \code{P}.
\end{description}

\subsection{General options}

\begin{description}
	%\item[{autocomplete = [false, true]}] Turn autocompletion of structures on or off
	%\item[{cpsupport = [false, true]}] Enable/disable cp-support (running a cp-solver together with the SAT-solver)
	%\item[{createtranslation = [false, true]}] \todo{watdoetdit?}
	%\item[{groundlazily = [false, true]}] Enable/disable lazy grounding
	%\item[{printtypes = [false, true]}] \todo{doet niets voor de moment?}
	%\item[{provertimeout = [0..2147483647]}] \todo{?}
	%\item[{showwarnings = [false, true]}] Enable/disable the warnings.
	%\item[{symmetry = [0..2147483647]}] \todo{?} 1 is static, 0 is none, higher = ?
	\item[{timeout = [0..max(int)]}] Set the timeout for inferences (in seconds)
	\item[{seed = [0..max(int)]}] Set the seed for the random generator (used in the estimators for BDDs and in the SAT-solver)
	\item[{randomvaluechoice = [false, true]}] Controls the solver: if set to true, the assignment to choice literals is random, if set to false, the solver default assigns false to choice literals.
\end{description}



\end{document}
