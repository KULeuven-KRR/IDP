// NOTE: the argument names are used literally in the help information, so they should be readable!

namespace stdspace{
	
/***********
	Help
***********/

/**
 * List the procedures in the given namespace  */
procedure help(namespace ) {
	namespace = namespace or idpglobal
	if type(namespace) == "namespace" then
		idpintern.help(namespace)
	else
		print("Error: namespace expected")
	end
}

/**************************
	Iterate over tables
**************************/

/**
 * Returns a procedure, iterator, and a tuple such that
 * for t in tuples(table) do ... end
 * iterates over all tuples in the given predicate table.*/
procedure tuples(table) {
	if type(table) == "predicate_table" then
		return idpintern.deref_and_increment, iterator(table), createdummytuple()
	else
		print("Error: predicate table expected")
	end
}

/**
 * Returns a procedure, iterator, and 0 such that
 * for e in elements(d) do ... end
 * iterates over all elements in the given domain d.*/
procedure elements(d) {
	if type(d) == "domain" then
		return idpintern.deref_and_increment, iterator(d), 0
	else 
		print("Error: domain expected")
	end
}

/**
* Returns custom typeids for first-class idp citizens.*/
procedure idptype(something){
	return idpintern.idptype(something)
}

namespace inferences{

/**
 * Apply model expansion to theory T, structure S over the same vocabulary.
 * The result is a table of two-valued structures and, if getoptions().trace == true, a trace of the solver */
procedure modelexpand(theory, structure) {
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	local solutions, trace = modelexpandpartial(theory,structure)
	local solutions2 = alltwovaluedextensions(solutions)
	return solutions2, trace
}

/**
 * Apply model expansion to theory T, structure S over the same vocabulary.
 * The result is a table of (possibly three-valued) structures and, if getoptions().trace == true, a trace of the solver */
procedure modelexpandpartial(theory, structure) {
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.modelexpand(clonetheo,structure)
}

/**
 * Checks satisfiability of the given theory-structure combination over the same vocabulary. 
 * Returns true if and only if there exists a model extending the structure satisfying the theory.
 */
procedure sat(theory, structure) {
	Opts = getoptions()
	local oldnbmodels = Opts.nbmodels
	Opts.nbmodels = 1
	local solutions = modelexpandpartial(theory,structure)
	Opts.nbmodels = oldnbmodels
	return #solutions>0
}

/**
 *  Returns all models of the theory that extend the given structure and such that the term is minimal.
 */
procedure minimize(theory, structure, term){
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	if type(term) ~= "term" then
		print("Error: term expected")
		return
	end
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	local solutions, trace = idpintern.minimize(clonetheo,structure, term)
	local solutions2 = alltwovaluedextensions(solutions)
	return solutions2, trace
}

/**
 * Create the reduced grounding of the given theory and structure and parameter on whether the grounding should preserve the number of models */
procedure groundeq(theory, structure, modeleq) {	
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.ground(clonetheo,structure, modeleq) 
}

/**
 * Create the reduced grounding of the given theory and structure, preserving the number of models */
procedure ground(theory, structure) {
	return groundeq(theory,structure, true) 
}


/**
 * Print the reduced grounding of the given theory and structure
 * MEMORY EFFICIENT: does not store the grounding internally */
procedure printgrounding(theory, structure) {
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.printgrounding(clonetheo,structure, true) 
}

/**
* Return a structure, made more precise than the input by generating all models and checking which literals always have the same truth value.
* This propagation is complete: everything that can be derived from the theory will be derived. 
* Returns nil when propagation results in an inconsistent structure.*/ 
procedure optimalpropagate(theory,structure){
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.optimalpropagate(clonetheo,structure) 
}

/**
* Return a structure, made more precise than the input by grounding and unit propagation on the theory. 
* Returns nil when propagation results in an inconsistent structure.*/
procedure groundpropagate(theory,structure){
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.groundpropagate(clonetheo,structure) 
}

/**
* Return a structure, made more precise than the input by doing symbolic propagation on the theory. 
* Returns nil when propagation results in an inconsistent structure.*/
procedure propagate(theory,structure){
	if type(theory) ~= "theory" then
		print("Error: theory expected")
		return
	end
	if type(structure) ~= "structure" then
		print("Error: structure expected")
		return
	end
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.propagate(clonetheo,structure) 
}

/*/**
 * Check whether first theory entails the second */
/*procedure entails(theory1, theory2) {
	tmplang = stdoptions.language
	stdoptions.language = "tptp"
	fof_commands = {idp_intern.prover_fof_linux, idp_intern.prover_fof_win, idp_intern.prover_fof_osx}
	tff_commands = {idp_intern.prover_tff_linux, idp_intern.prover_tff_win, idp_intern.prover_tff_osx}
	result = idpintern.entails(
		theory1,
		theory2,
		fof_commands,
		tff_commands,
		idpintern.prover_fof_truestrings,
		idpintern.prover_fof_falsestrings,
		idpintern.prover_tff_truestrings,
		idpintern.prover_tff_falsestrings
	)
	stdoptions.language = tmplang
	return result
}*/

}

}
