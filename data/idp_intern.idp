/***********
	Help
***********/

/**
 * List the procedures in the given namespace 
 */
procedure help(namespace) {
	if (not namespace) then namespace = global_namespace end
	idp_intern.help(namespace)
}

/**************************
	Iterate over tables
**************************/

/**
 * Returns a procedure, iterator, and a tuple such that 
 *    for t in tuples(table) do ... end
 * iterates over all tuples in the given predicate table
 */
procedure tuples(table) {
	if type(table) == "predicate_table" then
		return idp_intern.deref_and_increment, idp_intern.tableIterator(table), idp_intern.dummytuple()
	else
		print("Error: predicate table expected")
	end
}

/**
 * Returns a procedure, iterator, and 0 such that
 *    for e in elements(d) do ... end
 * iterates over all elements in the given domain d
 */
procedure elements(d) {
	if type(d) == "domain" then
		return idp_intern.deref_and_increment, idp_intern.domainIterator(d), 0
	else 
		print("Error: domain expected")
	end
}

/************************
	Create new objects 
************************/

/** 
 * Create a new structure over a given vocabulary voc. 
 * The created structure assigns the least precise interpretation to every symbol of its vocabulary.  
 */
procedure newStructure(voc) {
	return idp_intern.newStructure(voc)
}

/**
 * Create a new, empty theory over a given vocabulary voc
 */
procedure newTheory(voc) {
	return idp_intern.newTheory(voc)
}

/**
 * Create a new block of options
 */
procedure newOptions() {
	return idp_intern.newOptions()
}

/**
 * Create a copy of the object obj
 */
procedure clone(obj) {
	return idp_intern.clone(obj)
}

/**********************
	Basic inference
**********************/

/**
 * Solve a query Q over a structure S
 */
procedure query(Q,S) {
	return idp_intern.query(Q,S)
}

/**
 * Apply model expansion to theory T, structure S, and options Opts. Opts defaults to stdoptions.
 * The result is a table of structures and, if Opts.trace == true, a trace of the solver
 */
procedure modelExpand(T,S,Opts) {
	local clonetheo = clone(T)
	idp_intern.pushNegations(clonetheo)
	idp_intern.flatten(clonetheo)
	if not Opts then Opts = stdoptions end
	local solutions, trace =  idp_intern.modelExpand(clonetheo,S,Opts) 
	return solutions, trace
}

/**
 * Create the reduced grounding of theory T and structure S
 */
procedure ground(T,S,Opts) {
	local clonetheo = clone(T)
	idp_intern.pushNegations(clonetheo)
	idp_intern.flatten(clonetheo)
	if not Opts then Opts = stdoptions end
	return idp_intern.ground(clonetheo,S,Opts) 
}

/**
 * Print the reduced grounding of theory T and structure S (without storing it)
 */
procedure printGrounding(T,S,Opts) {
	local clonetheo = clone(T)
	idp_intern.pushNegations(clonetheo)
	idp_intern.flatten(clonetheo)
	if not Opts then Opts = stdoptions end
	return idp_intern.printGrounding(clonetheo,S,Opts) 
}

/**
 * Apply unit propagation on a theory T and structure S
 */
procedure propagate(T,S,Opts) {
	if not Opts then Opts = stdoptions end
	return idp_intern.propagate(T,S,Opts)
}

/**
 * Change the vocabulary of a structure S to vocabulary V
 * If some symbol occurs both in V and in the previous vocabulary of S, its interpretation in S is kept.
 * For all symbols that belong to V but not to the previous vocabulary of S, 
 * the interpretation in S is initialized to the least precise interpretation.
 */
procedure changeVocabulary(S,V) {
	idp_intern.changeVocabulary(S,V)
}

/**
 * Make a tuple true in a predicate interpretation
 */
procedure makeTrue(inter,tuple) {
	idp_intern.makeTrue(inter,tuple)
}

/**
 * Make a tuple false in a predicate interpretation
 */
procedure makeFalse(inter,tuple) {
	idp_intern.makeFalse(inter,tuple)
}

/**
 * Make a tuple unknown in a predicate interpretation
 */
procedure makeUnknown(inter,tuple) {
	idp_intern.makeUnknown(inter,tuple)
}

