/***********
	Help
***********/

/**
 * List the procedures in the given namespace 
 */
procedure help(namespace) {
	if (not namespace) then namespace = global_namespace end
	idp_intern.help(namespace)
}

/**********************
	Default options 
**********************/

options stdoptions {
	nrmodels=1
	language=idp
	modelformat=all
}

/************************
	Create new objects 
************************/

/** 
 * Create a new structure over a given vocabulary voc. 
 * The created structure assigns the least precise interpretation to every symbol of its vocabulary.  
 */
procedure newstructure(voc) {
	return idp_intern.newstructure(voc)
}

/**
 * Create a new, empty theory over a given vocabulary voc
 */
procedure newtheory(voc) {
	return idp_intern.newtheory(voc)
}

/**
 * Create a new block of options
 */
procedure newoptions() {
	return idp_intern.newoptions()
}

/**
 * Create a copy of the object obj
 */
procedure clone(obj) {
	return idp_intern.clone(obj)
}

/**********************
	Basic inference
**********************/

/**
 * Apply model expansion to theory T, structure S, and options Opts. Opts defaults to stdoptions.
 * The result is a table of structures and, if Opts.trace == true, a trace of the solver
 */
procedure modelexpand(T,S,Opts) {
	local clonetheo = clone(T)
	internal_inference::push_negations(clonetheo)
	internal_inference::flatten(clonetheo)
	if not Opts then Opts = stdoptions end
	local solutions, trace =  idp_intern.mx(clonetheo,S,Opts) 
	return solutions, trace
}

/**
 * Create the reduced grounding of theory T and structure S
 */
procedure ground(T,S,Opts) {
	local clonetheo = clone(T)
	internal_inference::push_negations(clonetheo)
	internal_inference::flatten(clonetheo)
	if not Opts then Opts = stdoptions end
	return idp_intern.ground(clonetheo,S,Opts) 
}

/*************************
	Advanced inference
*************************/

namespace internal_inference {

	/**
	 * Push the negations of a given theory T inside until they are in front of atoms
	 */
	procedure push_negations(T) {
		return idp_intern.push_negations(T)
	}

	/**
	 * Remove brackets from long conjunctions and disjunctions in theory T
	 * Merge successive quantifiers in theory T
	 */
	procedure flatten(T) {
		return idp_intern.flatten(T)
	}

}















/*
procedure cast(obj,newtype) {
	if type(obj) == newtype then 
		return obj
	elseif type(obj) == "overloaded" then
		return idp_intern_idpcall("cast",obj,newtype)
	elseif type(obj) == "structure" and newtype == "theory" then
		return idp_intern_idpcall("convert_to_theory",S)
	else 
		print("Error: impossible cast")
	end
}


procedure changevoc(Struct,Voc) {
	return idp_intern_idpcall("changevoc",Struct,Voc)
}

procedure parse(filename) {
	return idp_intern_idpcall("load_file",filename)
}

procedure ground(Theo,Struct,Opt) {
	local clonetheo = clone(Theo)
	IDP_ADVANCED::push_negations(clonetheo)
	IDP_ADVANCED::flatten(clonetheo)
	if not Opt then Opt = stdoptions end
	return idp_intern_idpcall("fastground",clonetheo,Struct,Opt)
}

procedure modelcheck(Theo,Struct) {
	// TODO: check if two-valued
	// assert(twovalued(Struct),"Procedure modelcheck/2 requires a two-valued structure as second argument")
	opts = newoptions()
	setoption(opts,"nrmodels",1)
	sols = modelexpand(Theo,Struct,opts)
	return #sols == 1
}

procedure idptostring(obj,opts) {
	if not opts then opts = stdoptions end
	return idp_intern_idpcall("print",obj,opts)
}

namespace IDP_ADVANCED {
	
	procedure move_functions(T) {
		return idp_intern_idpcall("move_functions",T)
	}

	procedure move_quantifiers(T) {
		return idp_intern_idpcall("move_quantifiers",T)
	}

	procedure remove_eqchains(T) {
		return idp_intern_idpcall("remove_eqchains",T)
	}

	procedure remove_equivalences(T) {
		return idp_intern_idpcall("remove_equivalences",T)
	}

	procedure tseitin(T) {
		return idp_intern_idpcall("tseitin",T)
	}

	procedure reduce(T,S) {
		return idp_intern_idpcall("reduce",T,S)
	}

	procedure totheory(S) {
		return idp_intern_idpcall("convert_to_theory",S);
	}

	procedure forcetwovalued(S) {
		return idp_intern_idpcall("forcetwovalued",S);
	}

	procedure getbdds(T) {
		return idp_intern_idpcall("getbdds",T);
	}
*/
