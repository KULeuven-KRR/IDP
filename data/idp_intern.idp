/**********************
	Default options 
**********************/

options stdoptions {
	nrmodels=1
	language=idp
	modelformat=all
}

/************************
	Create new objects 
************************/

/**
 * Create a new structure over a given vocabulary voc. 
 * The created structure assigns the least precise interpretation to every symbol of its vocabulary.
 */
procedure newstructure(voc) {
	return idp_intern.newstructure(voc)
}

/**
 * Create a new, empty theory over a given vocabulary voc
 */
procedure newtheory(voc) {
	return idp_intern.newtheory(voc)
}

/**
 * Create a new block of options
 */
procedure newoptions() {
	return idp_intern.newoptions()
}

/**
 * Create a copy of the object obj
 */
procedure clone(obj) {
	return idp_intern.clone(obj)
}

/**********************
	Basic inference
**********************/

















/** Casting **/

procedure cast(obj,newtype) {
	if type(obj) == newtype then 
		return obj
	elseif type(obj) == "overloaded" then
		return idp_intern_idpcall("cast",obj,newtype)
	elseif type(obj) == "structure" and newtype == "theory" then
		return idp_intern_idpcall("convert_to_theory",S)
	else 
		print("Error: impossible cast")
	end
}

/** Vocabulary **/

procedure changevoc(Struct,Voc) {
	return idp_intern_idpcall("changevoc",Struct,Voc)
}

/** Parsing of files **/
procedure parse(filename) {
	return idp_intern_idpcall("load_file",filename)
}

/** Model expansion **/
procedure modelexpand(Theo,Struct,Opt) {
	local clonetheo = clone(Theo)
	IDP_ADVANCED::push_negations(clonetheo)
	IDP_ADVANCED::flatten(clonetheo)
	if not Opt then Opt = stdoptions end
	local solutions, trace =  idp_intern_idpcall("fastmx",clonetheo,Struct,Opt) 
	return solutions, trace
}

/** Grounding **/
procedure ground(Theo,Struct,Opt) {
	local clonetheo = clone(Theo)
	IDP_ADVANCED::push_negations(clonetheo)
	IDP_ADVANCED::flatten(clonetheo)
	if not Opt then Opt = stdoptions end
	return idp_intern_idpcall("fastground",clonetheo,Struct,Opt)
}

/** Model checking **/
procedure modelcheck(Theo,Struct) {
	// TODO: check if two-valued
	// assert(twovalued(Struct),"Procedure modelcheck/2 requires a two-valued structure as second argument")
	opts = newoptions()
	setoption(opts,"nrmodels",1)
	sols = modelexpand(Theo,Struct,opts)
	return #sols == 1
}

/** Printing **/
procedure idptostring(obj,opts) {
	if not opts then opts = stdoptions end
	return idp_intern_idpcall("print",obj,opts)
}

/** Procedures for advanced use of IDP **/
namespace IDP_ADVANCED {
	
	procedure push_negations(T) {
		return idp_intern_idpcall("push_negations",T)
	}

	procedure move_functions(T) {
		return idp_intern_idpcall("move_functions",T)
	}

	procedure move_quantifiers(T) {
		return idp_intern_idpcall("move_quantifiers",T)
	}

	procedure remove_eqchains(T) {
		return idp_intern_idpcall("remove_eqchains",T)
	}

	procedure remove_equivalences(T) {
		return idp_intern_idpcall("remove_equivalences",T)
	}

	procedure tseitin(T) {
		return idp_intern_idpcall("tseitin",T)
	}

	procedure flatten(T) {
		return idp_intern_idpcall("flatten",T)
	}

	procedure reduce(T,S) {
		return idp_intern_idpcall("reduce",T,S)
	}

	procedure totheory(S) {
		return idp_intern_idpcall("convert_to_theory",S);
	}

	procedure forcetwovalued(S) {
		return idp_intern_idpcall("forcetwovalued",S);
	}

	procedure getbdds(T) {
		return idp_intern_idpcall("getbdds",T);
	}

}

