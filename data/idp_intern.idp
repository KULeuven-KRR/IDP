/** Options **/

#options DefaultOptions {
	nrmodels=1
	language=idp
	modelformat=all
}

#procedure setoption(Opts,OptName,OptValue) {
	return idp_intern.idpcall("setoption",Opts,OptName,OptValue)
}

#procedure setoption(OptName,OptValue) {
	return setoption(DefaultOptions,OptName,OptValue)
}

#procedure getoption(Opts,OptName) {
	local val = idp_intern.idpcall("getoption",Opts,OptName)
	local numval = tonumber(val)
	if numval then 
		return numval
	elseif numval == "true" then 
		return true
	elseif numval == "false" then 
		return false
	else 
		return val
	end
}

#procedure getoption(OptName) {
	return getoption(DefaultOptions,OptName)
}

/** Create new blocks **/

#procedure newoptions(Opts) {
	return idp_intern.idpcall("newoptions",Opts)
}

#procedure newoptions() {
	return idp_intern.idpcall("newoption")
}

#procedure clone(obj) {
	return idp_intern.idpcall("clone",obj)
}

/** Vocabulary **/

#procedure changevoc(Struct,Voc) {
	return idp_intern.idpcall("changevoc",Struct,Voc)
}

/** Parsing of files **/
#procedure parse(filename) {
	return idp_intern.idpcall("load_file",filename)
}

/** Model expansion **/
#procedure modelexpand(Theo,Struct,Opt) {
	local clonetheo = clone(Theo)
	IDP_ADVANCED::push_negations(clonetheo)
	IDP_ADVANCED::flatten(clonetheo)
	return idp_intern.idpcall("fastmx",clonetheo,Struct,Opt)
}

#procedure modelexpand(Theo,Struct) {
	return modelexpand(Theo,Struct,DefaultOptions)
}

/** Grounding **/
#procedure ground(Theo,Struct) {
	local clonetheo = clone(Theo)
	IDP_ADVANCED::push_negations(clonetheo)
	IDP_ADVANCED::flatten(clonetheo)
	return idp_intern.idpcall("fastground",clonetheo,Struct)
}

/** Model checking **/
#procedure modelcheck(Theo,Struct) {
	// TODO: check if two-valued
	// assert(twovalued(Struct),"Procedure modelcheck/2 requires a two-valued structure as second argument")
	opts = newoptions()
	setoption(opts,"nrmodels",1)
	sols = modelexpand(Theo,Struct,opts)
	return #sols == 1
}

/** Printing **/
#procedure idptostring(obj) {
	return idp_intern.idpcall("print",obj)
}

#procedure idptostring(obj,opts) {
	return idp_intern.idpcall("print",obj,opts)
}

/** Procedures for advanced use of IDP **/
#namespace IDP_ADVANCED {
	
	#procedure push_negations(T) {
		return idp_intern.idpcall("push_negations",T)
	}

	#procedure move_functions(T) {
		return idp_intern.idpcall("move_functions",T)
	}

	#procedure move_quantifiers(T) {
		return idp_intern.idpcall("move_quantifiers",T)
	}

	#procedure remove_eqchains(T) {
		return idp_intern.idpcall("remove_eqchains",T)
	}

	#procedure remove_equivalences(T) {
		return idp_intern.idpcall("remove_equivalences",T)
	}

	#procedure tseitin(T) {
		return idp_intern.idpcall("tseitin",T)
	}

	#procedure convert_to_theory(S) {
		return idp_intern.idpcall("convert_to_theory",S)
	}

	#procedure flatten(T) {
		return idp_intern.idpcall("flatten",T)
	}

	#procedure reduce(T,S) {
		return idp_intern.idpcall("reduce",T,S)
	}

	#procedure totheory(S) {
		return idp_intern.idpcall("convert_to_theory",S);
	}

	#procedure forcetwovalued(S) {
		return idp_intern.idpcall("forcetwovalued",S);
	}

}

