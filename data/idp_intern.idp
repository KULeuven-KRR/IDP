// NOTE: the argument names are used literally in the help information, so they should be readable!

/***********
	Help
***********/

/**
 * List the procedures in the given namespace 
 */
procedure help(namespace) {
	if (not namespace) then namespace = idpglobal end
	idpintern.help(namespace)
}

/**************************
	Iterate over tables
**************************/

/**
 * Returns a procedure, iterator, and a tuple such that 
 *    for t in tuples(table) do ... end
 * iterates over all tuples in the given predicate table
 */
procedure tuples(table) {
	if type(table) == "predicate_table" then
		return deref_and_increment, iterator(table), createdummytuple()
	else
		print("Error: predicate table expected")
	end
}

/**
 * Returns a procedure, iterator, and 0 such that
 *    for e in elements(d) do ... end
 * iterates over all elements in the given domain d
 */
procedure elements(d) {
	if type(d) == "domain" then
		return deref_and_increment, iterator(d), 0
	else 
		print("Error: domain expected")
	end
}

/**********************
	Basic inference
**********************/

/**
 * Apply model expansion to theory T, structure S, and options Opts. Opts defaults to stdoptions.
 * The result is a table of structures and, if Opts.trace == true, a trace of the solver
 */
procedure modelexpand(theory, structure) {
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	local solutions, trace = idpintern.modelexpand(clonetheo,structure) 
	local solutions2 = alltwovaluedextensions(solutions)
	return solutions2, trace
}

/**
 * Create the reduced grounding of the given theory and structure
 */
procedure ground(theory, structure) {
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.ground(clonetheo,structure) 
}

/**
 * Print the reduced grounding of the given theory and structure
 * MEMORY EFFICIENT: does not store the grounding internally
 */
procedure printgrounding(theory, structure) {
	local clonetheo = clone(theory)
	pushnegations(clonetheo)
	flatten(clonetheo)
	return idpintern.printgrounding(clonetheo,structure) 
}

/**
 * Check whether first theory entails the second
 */
procedure entails(theory1, theory2) {
	tmplang = stdoptions.language
	stdoptions.language = "tptp"
	fof_commands = {idp_intern.prover_fof_linux, idp_intern.prover_fof_win, idp_intern.prover_fof_osx}
	tff_commands = {idp_intern.prover_tff_linux, idp_intern.prover_tff_win, idp_intern.prover_tff_osx}
	result = idpintern.entails(
		theory1,
		theory2,
		fof_commands,
		tff_commands,
		idpintern.prover_fof_truestrings,
		idpintern.prover_fof_falsestrings,
		idpintern.prover_tff_truestrings,
		idpintern.prover_tff_falsestrings
	)
	stdoptions.language = tmplang
	return result
}
